#!/usr/bin/env perl
# -*-mode:cperl; indent-tabs-mode: nil-*-

## Script to control Bucardo
##
## Copyright 2006-2011 Greg Sabino Mullane <greg@endpoint.com>
##
## Please see http://bucardo.org/ for full documentation

package bucardo;
use strict;
no strict 'refs';
use warnings;
use 5.008003;
use DBI;
use IO::Handle;
use Getopt::Long;
Getopt::Long::Configure(qw/no_ignore_case/);
use Time::HiRes 'sleep';
use POSIX qw/ceil setsid localeconv/;
use Data::Dumper 'Dumper';
$Data::Dumper::Indent = 1;

return 1 if $ENV{BUCARDO_TEST};

our $VERSION = '5.0.0';

*STDOUT->autoflush(1);
*STDERR->autoflush(1);

use vars qw/$dbh $SQL $sth %sth $count $info %global $SYNC $GOAT $DB $DBGROUP $HERD/;

my $DATEFORMAT       = q{Mon DD, YYYY HH24:MI:SS};
my $SHORTDATEFORMAT  = q{HH24:MI:SS};
my $DEFAULT_DAYSBACK = 3;
my $WAITSLEEP        = 1;
my $PROGRESS         = 1;

my $progname = $0;
if (exists $ENV{PATH} and $progname =~ m{(.+)/(.+)}) {
    my ($base, $name) = ($1,$2);
    for my $seg (split /\:/ => $ENV{PATH}) {
        if ($seg eq $base) {
            $progname = $name;
            last;
        }
    }
}

help() unless @ARGV;

## Default arguments - most are for the bc constructor
my $bcargs = {
              quiet        => 0,
              verbose      => 0,
              bcverbose    => 1,
              dbname       => 'bucardo',
              dbuser       => 'bucardo',
              dbpass       => '',
              sendmail     => 0,
              extraname    => '',
              debugfilesep => 0,
              debugdir     => '.',
              debugname    => '',
              debugsyslog  => 1,
              debugfile    => 1,
              cleandebugs  => 0,
              batch        => 0,
          };

## These options must come before the GetOptions call
for my $arg (@ARGV) {
    if ($arg eq '--no-bucardorc') {
        $bcargs->{'no-bucardorc'} = 1;
    }
    if ($arg =~ /--bucardorc=(.+)/) {
        $bcargs->{'bucardorc'} = $1;
    }
    if ($arg =~ /^-+\?$/) {
        help();
    }
}

## Values are first read from a .bucardorc, either in the current dir, or the home dir.
## These will be overwritten by command-line args.
my $file;
if (! $bcargs->{'no-bucardorc'}) {
    if ($bcargs->{bucardorc}) {
        -e $bcargs->{bucardorc} or die qq{Could not find the file "$bcargs->{bucardorc}"\n};
        $file = $bcargs->{bucardorc};
    }
    elsif (-e '.bucardorc') {
        $file = '.bucardorc';
    }
    elsif (-e "$ENV{HOME}/.bucardorc") {
        $file = "$ENV{HOME}/.bucardorc";
    }
    elsif (-e '/etc/bucardorc') {
        $file = '/etc/bucardorc';
    }
}
if (defined $file) {
    open my $rc, '<', $file or die qq{Could not open "$file": $!\n};
    while (<$rc>) {
        next if /^\s*#/;
        next unless /^\s*(\w+)\s*=\s*(.+?)\s*$/o;
        my ($name,$value) = ($1,$2); ## no critic (ProhibitCaptureWithoutTest)
        $bcargs->{$name} = $value;
    }
    close $rc or die;
}

GetOptions ## no critic (ProhibitCallsToUndeclaredSubs)
    ($bcargs,
     'verbose+',
     'vv',
     'quiet+',
     'notimer',
     'help',
     'debug',
     'version',
     'daysback=i',
     'sort=i',
     'showdays',
     'compress',
     'retry=i',
     'retrysleep=i',
     'batch',
     'dryrun|dry-run',
     'confirm',
     'tsep=s',

     ## These are sent to the constructor:
     'bcverbose',
     'dbport=i',
     'dbhost=s',
     'dbname=s',
     'dbuser=s',
     'dbpass=s',
     'sendmail=i',
     'extraname=s',
     'debugfilesep',
     'debugname=s',
     'debugsyslog=i',
     'debugdir=s',
     'debugfile=i',
     'cleandebugs=i',
     'force',

     ## Used internally
     'schema|n=s@',
     'exclude-schema|N=s@',
     'table|t=s@',
     'exclude-table|T=s@',
     'db=s',
     'herd=s',
     'piddir=s',
     ## These two already handled above, but need to be here so GetOptions is happy:
     'bucardorc=s',
     'no-bucardorc',

) or die "\n";

my $QUIET = delete $bcargs->{quiet};

help() if $bcargs->{help};

if ($bcargs->{version}) {
    print "bucardo version $VERSION\n";
    exit 0;
}

$bcargs->{vv} and $bcargs->{verbose} = 2;
my $VERBOSE    = delete $bcargs->{verbose};
my $DEBUG      = delete $bcargs->{debug} || $ENV{BUCARDO_DEBUG} || 0;
my $DAYSBACK   = delete $bcargs->{daysback} || $DEFAULT_DAYSBACK;
my $COMPRESS   = delete $bcargs->{compress};
my $SHOWDAYS   = delete $bcargs->{showdays} || 1;
my $RETRY      = delete $bcargs->{retry} || 0;
my $RETRYSLEEP = delete $bcargs->{retrysleep} || 0;
my $NOTIMER    = delete $bcargs->{notimer} || 0;

my $DBCONN = "User: $bcargs->{dbuser}  Database: $bcargs->{dbname}";
$bcargs->{dbhost} and length $bcargs->{dbhost} and $DBCONN .= "  Host: $bcargs->{dbhost}";
$bcargs->{dbport} and length $bcargs->{dbport} and $DBCONN .= "  Port: $bcargs->{dbport}";

## Anything left over is the verb and noun(s)

my $verb = shift || '';
help() unless $verb;
$verb = lc $verb;
my @nouns = @ARGV;
my $nouns = join ' ' => @nouns;

## Installation must happen before we try to connect!
install() if $verb eq 'install';

## Grab current information from the bucardo_config file
my $DSN = "dbi:Pg:dbname=$bcargs->{dbname}";
$bcargs->{dbhost} and length $bcargs->{dbhost} and $DSN .= ";host=$bcargs->{dbhost}";
$bcargs->{dbport} and length $bcargs->{dbport} and $DSN .= ";port=$bcargs->{dbport}";
$dbh = DBI->connect($DSN, $bcargs->{dbuser}, $bcargs->{dbpass}, {AutoCommit=>0,RaiseError=>1,PrintError=>0});
$dbh->do('SET search_path = bucardo');
check_version($dbh);
$dbh->do('LISTEN bucardo');
$dbh->commit();

my $REASONFILE = get_config('reason_file') or die "Invalid reason_file!\n";
my $PIDDIR     = get_config('piddir') or die "Invalid piddir!\n";
my $pidfile    = 'bucardo.mcp.pid';
my $stopfile   = get_config('stopfile') or die "Invalid stopfile!\n";

my $PIDFILE        = "$PIDDIR/$pidfile";
my $REASONFILE_LOG = "$REASONFILE.log";
my $STOPFILE       = "$PIDDIR/$stopfile";

## Aliases for terms people may shorten, misspell, etc.
## Mostly used for database columns when doing an 'update'
our %alias = (
    'ssp'                 => 'server_side_prepares',
    'server_side_prepare' => 'server_side_prepares',
    'port'                => 'dbport',
    'host'                => 'dbhost',
    'name'                => 'dbname',
    'user'                => 'dbuser',
    'pass'                => 'dbpass',
    'password'            => 'dbpass',
    'service'             => 'dbservice',
);

my %column_no_change = (
    'cdate' => 1,
);

## Regular expressions

my $re_dbgroupname = qr{\w[\w\d]*};
my $re_dbname = qr{\w[\w\d]*};

## Handle all the simple verbs
ping()          if $verb eq 'ping';
superhelp()     if $verb eq 'help';

## Handle all the verbs that may require us to load information
load_bucardo_info();
status_all()    if $verb eq 'status' and ! @nouns;
status_detail() if $verb eq 'status';
restart()       if $verb eq 'restart';
start()         if $verb eq 'start';
stop()          if $verb eq 'stop';
reload_config() if $verb eq 'reload_config';
reload()        if $verb eq 'reload';
add_item()      if $verb eq 'add';
remove_item()   if $verb eq 'remove' or $verb eq 'delete';
upgrade()       if $verb eq 'upgrade' or $verb eq 'uprgade';
message()       if $verb eq 'message';
list()          if $verb eq 'list' or $verb eq 'l' or $verb eq 'lsit';;
config()        if $verb eq 'set' or $verb eq 'show' or $verb eq 'config';
validate()      if $verb eq 'validate';
update()        if $verb eq 'update';
inspect()       if $verb eq 'inspect';

if ($verb ne 'kick' and $verb ne 'activate' and $verb ne 'deactivate') {
    help();
}

## For the rest, we expect a list of syncs with an optional decimal "timeout"
my $adverb;
my $syncs = get_syncs();
my @syncs;
my $gotall = 0;
my @allvars;
SYNCMATCH: for my $sync (@nouns) {

    if ($sync =~ /^\d+$/) {
        $adverb = $sync;
        next SYNCMATCH;
    }

    if ($sync eq 'all') { ## All proceeding nouns are treated special!
        $gotall = 1;
        next SYNCMATCH;
    }

    if ($gotall) {
        push @allvars => $sync;
        next;
    }

    if ($sync =~ /%/) {
        $SQL = qq{SELECT name FROM bucardo.sync WHERE name LIKE '$sync'};
        my $tmp = $dbh->selectall_arrayref($SQL);
        push @syncs, (map { $_->[0] } @$tmp);
        next SYNCMATCH;
    }
    if ($sync =~ /^\*(\w+)\*$/) {
        $SQL = qq{SELECT name FROM bucardo.sync WHERE name ~ '$1'};
        my $tmp = $dbh->selectall_arrayref($SQL);
        push @syncs => map { $_->[0] } @$tmp;
        next SYNCMATCH;
    }
    if ($sync =~ /^\*(\w+)$/) {
        $SQL = qq{SELECT name FROM bucardo.sync WHERE name ~ '$1\$'};
        my $tmp = $dbh->selectall_arrayref($SQL);
        push @syncs => map { $_->[0] } @$tmp;
        next SYNCMATCH;
    }
    if ($sync =~ /^(\w+)\*$/) {
        $SQL = qq{SELECT name FROM bucardo.sync WHERE name ~ '^$1'};
        my $tmp = $dbh->selectall_arrayref($SQL);
        push @syncs => map { $_->[0] } @$tmp;
        next SYNCMATCH;
    }
    next if $sync eq 'sync';

    if (! exists $syncs->{$sync}) {
        ## Be nice and print a list of active syncs
        my @goodsyncs;
        for my $s (sort keys %$syncs) {
            push @goodsyncs => $s if $syncs->{$s}{status} eq 'active';
        }
        my $msg = qq{Sync "$sync" does not appear to exist\n};
        if (@goodsyncs) {
            $msg .= "Active syncs:\n";
            $msg .= join "\n" => @goodsyncs;
        }
        die "$msg\n";
    }

    push @syncs, $sync;

}

if ($gotall) {
    my @typelimit;
    my $active = 0;
    for my $v (@allvars) {
        if ($v =~ /^(?:copy|fullcopy)$/i) {
            push @typelimit => 'fullcopy';
        }
        elsif ($v =~ /^(?:delta|pushdelta)$/i) {
            push @typelimit => 'pushdelta';
        }
        elsif ($v =~ /^swap$/i) {
            push @typelimit => 'swap';
        }
        elsif ($v =~ /^active$/i) {
            $active = 1;
        }
        else {
            die "Usage: ... all [copy|delta|swap]\n";
        }
    }
    my $WHERE = '';
    if (@typelimit) {
        $WHERE = 'WHERE ' . (join ' OR ' => map { "synctype = '$_'" } @typelimit);
    }
    if ($active) {
        $WHERE
            ? ($WHERE =~ s/WHERE /WHERE status = 'active' AND /)
            : ($WHERE = q{WHERE status = 'active'});
    }
    $SQL = "SELECT name FROM sync $WHERE ORDER BY priority DESC, name ASC";
    $sth = $dbh->prepare($SQL);
    undef @syncs;
    my $tmp = $dbh->selectall_arrayref($SQL);
    push @syncs => map { $_->[0] } @$tmp;
}

vate_sync() if $verb eq 'activate' or $verb eq 'deactivate';
kick() if $verb eq 'kick';

help();

sub numbered_relations {

    ## Return relations of the form schema.table in a sorted order
    ## in which we do alphabetical but switch to numeric order
    ## for any numbers at the end of the schema or the table

    my $uno = ref $a ? "$a->{schemaname}.$a->{tablename}" : $a;
    my $dos = ref $b ? "$b->{schemaname}.$b->{tablename}" : $b;

    ## Gather information for the first item
    die if $uno !~ /(.+)\.(.+)/;
    my ($schema1,$sbase1,$table1,$tbase1) = ($1,$1,$2,$2);
    my ($snum1, $tnum1) = (0,0);
    $sbase1 =~ s/(\d+)$// and $snum1 = $1;
    $tbase1 =~ s/(\d+)$// and $tnum1 = $1;

    ## Gather information for the second item
    die if $dos !~ /(.+)\.(.+)/;
    my ($schema2,$sbase2,$table2,$tbase2) = ($1,$1,$2,$2);
    my ($snum2, $tnum2) = (0,0);
    $sbase2 =~ s/(\d+)$// and $snum2 = $1;
    $tbase2 =~ s/(\d+)$// and $tnum2 = $1;

    return (
        $sbase1 cmp $sbase2
     or $snum1 <=> $snum2
     or $tbase1 cmp $tbase2
     or $tnum1 <=> $tnum2);

} ## end of numbered_relations


sub check_version {
    my $dbh = shift;
    my $res = $dbh->selectall_arrayref('SELECT version()')->[0][0];
    if ($res !~ /(\d+)\.(\d+)(\S+)/) {
        die "Sorry, unable to determine the database version\n";
    }
    my ($maj,$min,$rev) = ($1,$2,$3);
    $rev =~ s/^\.//;
    $rev =~ s/(\d+)\.\d+/$1/;
    if ($maj < 8 or (8 == $maj and $min < 1)) {
        die "Sorry, Bucardo requires Postgres version 8.1 or higher. This is only $maj.$min\n";
    }
}

sub help {
    warn qq{Usage: $progname args
  install         ** Install the Bucardo database

  start <reason>  ** Force any existing sync(s) to quit, then starts Bucardo

  stop <reason>   ** Tell all Bucardo processes to stop permanently

  list <type> [name]   ** View information about dbs, dbgroups, herds, syncs, tables, or sequences
  add <type> <name>    ** Add a db, dbgroup, herd, sync, table, or sequence
  remove <type> <name> ** Remove a db, dbgroup, herd, sync, table, or sequence
  For detailed help on the above, prefix with a help like this:
    $progname help add db

  kick <syncname(s)> [timeout]
                  ** Kick off one or more syncs, optionally wait for result (0 = wait until done)

  ping [timeout]  ** Ping the MCP process for a response, return a Nagios-friendly string

  status [--sort=col#] [--daysback=#]
                  ** List information about all syncs

  status syncname[s] [--daysback=#]
                  ** List detailed information about one or more syncs

  reload syncname[s]
                 ** Reload a sync

  validate syncname[s]
                 ** Validate a sync

  upgrade
                 ** Upgrade Bucardo to the current version

  message
                 ** Write a message to the Bucardo logs

  show [all|item]
  set [item=value]
                 ** View or set configuration parameters

  reload_config   ** Force a running Bucardo to reload the bucardo_config table

For more details, try 'man bucardo'
} unless $QUIET; ## Mostly for the test suite
    exit 0;
}


sub superhelp {

    ## See if we can get more specific by looking at the nouns
    help() if ! @nouns;

    my $word1 = lc $nouns[0];
    my $word2 = lc $nouns[1];

    ## Because usage() sometimes relies on the verb
    $verb = $word1;

    ## Allow plurals
    $word2 =~ s/s$//;

    if ('add' eq $word1) {
        if ('customcode' eq $word2 or 'custom_code' eq $word2 or 'code' eq $word2) {
            warn usage('add_customcode') . "\n";
            exit 0;
        }
        if ('db' eq $word2 or 'database' eq $word2) {
            warn usage('add_database') . "\n";
            exit 0;
        }
        if ('dbg' eq $word2 or 'dbgroup' eq $word2) {
            warn usage('add_dbgroup') . "\n";
            exit 0;
        }
        if ('herd' eq $word2) {
            warn usage('add_herd') . "\n";
            exit 0;
        }
        if ('sync' eq $word2) {
            warn usage('add_sync') . "\n";
            exit 0;
        }
        if ('table' eq $word2 or 'tab' eq $word2) {
            warn usage('add_table') . "\n";
            exit 0;
        }
        if ('sequence' eq $word2 or 'seq' eq $word2) {
            warn usage('add_sequence') . "\n";
            exit 0;
        }
        warn usage('add') . "\n";
        exit 0;
    }
    if ('config' eq $word1) {
        warn usage('config') . "\n";
        exit 0;
    }
    if ('inspect' eq $word1) {
        if ('table' eq $word2) {
            warn usage('inspect_table') . "\n";
            exit 0;
        }
        if ('herd' eq $word2) {
            warn usage('inspect_herd') . "\n";
            exit 0;
        }
        if ('sync' eq $word2) {
            warn usage('inspect_sync') . "\n";
            exit 0;
        }

        warn usage('inspect') . "\n";
        exit 0;
    }
    if ('kick' eq $word1) {
        warn usage('kick') . "\n";
        exit 0;
    }
    if ('list' eq $word1 or 'l' eq $word1) {
        if ('customcode' eq $word2 or 'custom_code' eq $word2) {
            warn usage('list_customcode') . "\n";
            exit 0;
        }
        if ($word2 =~ /^(?:db|database)/) {
            warn usage('list_databases') . "\n";
            exit 0;
        }
        if ('dbg' eq $word2 or 'dbgroup' eq $word2) {
            warn usage('list_dbgroups') . "\n";
            exit 0;
        }
        if ('herd' eq $word2) {
            warn usage('list_herds') . "\n";
            exit 0;
        }
        if ('sync' eq $word2) {
            warn usage('list_syncs') . "\n";
            exit 0;
        }
        if ('table' eq $word2 or 'tab' eq $word2) {
            warn usage('list_tables') . "\n";
            exit 0;
        }
        if ('sequence' eq $word2 or 'seq' eq $word2) {
            warn usage('list_sequences') . "\n";
            exit 0;
        }
        warn usage('list') . "\n";
        exit 0;
    }
    if ('message' eq $word1) {
        warn usage('message') . "\n";
        exit 0;
    }
    if ('ping' eq $word1) {
        warn usage('ping') . "\n";
        exit 0;
    }
    if ('reload' eq $word1) {
        warn usage('reload') . "\n";
        exit 0;
    }
    if ('reload_config' eq $word1) {
        warn usage('reload_config') . "\n";
        exit 0;
    }
    if ('remove' eq $word1 or 'delete' eq $word1) {
        if ('customcode' eq $word2 or 'custom_code' eq $word2) {
            warn usage('remove_customcode') . "\n";
            exit 0;
        }
        if ('db' eq $word2 or 'database' eq $word2) {
            warn usage('remove_database') . "\n";
            exit 0;
        }
        if ('dbg' eq $word2 or 'dbgroup' eq $word2) {
            warn usage('remove_dbgroup') . "\n";
            exit 0;
        }
        if ('herd' eq $word2) {
            warn usage('remove_herd') . "\n";
            exit 0;
        }
        if ('sync' eq $word2) {
            warn usage('remove_sync') . "\n";
            exit 0;
        }
        if ('table' eq $word2 or 'tab' eq $word2) {
            warn usage('remove_table') . "\n";
            exit 0;
        }
        if ('sequence' eq $word2 or 'seq' eq $word2) {
            warn usage('remove_sequence') . "\n";
            exit 0;
        }
        warn usage('remove') . "\n";
        exit 0;
    }
    if ('restart' eq $word1) {
        warn usage('restart') . "\n";
        exit 0;
    }
    if ('start' eq $word1) {
        warn usage('start') . "\n";
        exit 0;
    }
    if ('status' eq $word1) {
        warn usage('status') . "\n";
        exit 0;
    }
    if ('stop' eq $word1) {
        warn usage('stop') . "\n";
        exit 0;
    }
    if ('update' eq $word1) {
        warn usage('update') . "\n";
        exit 0;
    }
    if ('upgrade' eq $word1) {
        warn usage('upgrade') . "\n";
        exit 0;
    }
    if ('validate' eq $word1) {
        warn usage('validate') . "\n";
        exit 0;
    }

    ## Generic fallthrough
    help();

    exit 0;

} ## end of superhelp


sub restart {

    stop();
    sleep 1;
    start();
    return;

} ## end of restart


sub start {

    ## Attempt to start Bucardo

    append_reason_file('start');

    ## Refuse to go on if we get a ping response within 5 seconds
    $QUIET or print "Checking for existing processes\n";

    my $oldpid = 0;
    if ($oldpid) {
        $nouns = "Cannot start, process $oldpid is already running\n";
        $QUIET or print $nouns;
        append_reason_file('fail');
        exit 1;
    }

    my $dbversion = get_config('bucardo_current_version') or die "Could not find Bucardo version!\n";
    if ($dbversion ne $VERSION) {
        $nouns = "Version mismatch: bucardo is $VERSION, but bucardo database is $dbversion\n";
        append_reason_file('fail');
        warn $nouns;
        warn "Perhaps you need to run 'bucardo upgrade' ?\n";
        exit 1;
    }

    ## Create a new Bucardo instance and connect to its database
    require Bucardo;
    my $bc = Bucardo->new($bcargs);

    my $pm_version = $bc->{version} || 'unknown';
    if ($VERSION ne $pm_version) {
        $nouns = "Version mismatch: bucardo is $VERSION, but Bucardo.pm is $pm_version\n";
        append_reason_file('fail');
        die $nouns;
    }

    stop_bucardo();

    sleep 2; ## Give everyone a chance to notice it
    ## TODO: be smarter about this by scanning PIDDIR

    if (-e $STOPFILE) {
        print "Removing $STOPFILE\n" unless $QUIET;
        unlink $STOPFILE;
    }
    if (-e $PIDFILE) {
        print "Removing $STOPFILE\n" unless $QUIET;
        unlink $PIDFILE;
    }

    $QUIET or print qq{Starting Bucardo\n};

    $dbh->disconnect();
    if (fork) {
    }
    else {
        close STDERR or warn "Could not close STDERR\n";
        close STDOUT or warn "Could not close STDOUT\n";
        setsid() or die;
        $bc->start_mcp();
    }
    exit 0;

} ## end of start












##
## Database-related subroutines: add, remove, update, list
##

sub add_database {

    ## Add one or more databases. Inserts to the bucardo.db table
    ## By default, we do a test connection as well (turn off with the --force argument)
    ## Arguments: two or more
    ## 1. The internal name Bucardo uses to refer to this database
    ## 2+ name=value parameters, dash-dash arguments
    ## Returns: undef
    ## Example: bucardo add db nyc1 dbname=nyc1 host=nyc1.example.com group=sales

    ## Grab our generic usage message
    my $usage = usage('add_database');

    ## The first word is the internal name (bucardo.db.name)
    my $item_name = shift @nouns || '';

    ## No name is a problem
    if (!length $item_name) {
        warn "$usage\n";
        exit 1;
    }

    ## Inputs and aliases, database column name, flags, default
    my $validcols = qq{
        type                     dbtype               0                postgres
        name                     name                 0                $item_name
        db|dbname                dbname               0                $item_name
        user|dbuser|pguser       dbuser               0                bucardo
        host|dbhost|pghost       dbhost               0                ENV:PGHOSTADDR|PGHOST
        port|dbport|pgport       dbport               numeric          ENV:PGPORT
        pass|dbpass              dbpass               0                null
        conn|dbconn|pgconn       dbconn               0                null
        stat|status              status               =active|inactive null
        service|dbservice        dbservice            0                null
        pgpass                   pgpass               0                null
        sourcelimit              sourcelimit          numeric          null
        targetlimit              targetlimit          numeric          null
        makedelta                makedelta            =on|off          null
        makedelta_triggers       makedelta_triggers   TF               null
        server_side_prepares|ssp server_side_prepares TF               null
        group|dbgroup            none                 0                skip
        addalltables             none                 0                skip
        addallsequences          none                 0                skip
    };

    my ($dbcols,$cols,$phs,$vals,$extra)
        = process_simple_args({cols => $validcols, list => \@nouns, usage => $usage});

    ## Cannot add if already there
    if (exists $DB->{$item_name}) {
        print qq{Cannot add database: the name "$item_name" already exists\n};
        exit 1;
    }

    ## Clean up and standardize the names
    $vals->{dbtype} = lc $vals->{dbtype};
    $vals->{dbtype} =~ s/postgres.*/postgres/io;
    $vals->{dbtype} =~ s/drizzle.*/drizzle/io;
    $vals->{dbtype} =~ s/mongo.*/mongo/io;
    $vals->{dbtype} =~ s/mysql.*/mysql/io;
    $vals->{dbtype} =~ s/oracle.*/oracle/io;
    $vals->{dbtype} =~ s/redis.*/redis/io;

    ## Attempt to insert this into the database
    $SQL = "INSERT INTO bucardo.db ($cols) VALUES ($phs)";
    debug("SQL: $SQL");
    debug(Dumper $vals);
    $sth = $dbh->prepare($SQL);
    eval {
        $count = $sth->execute(map { $vals->{$_} } sort keys  %$vals);
    };
    if ($@) {
        if ($@ =~ /"db_dsn_unique"/) {
            die qq{Cannot add database: already have a connection with the same parameters\n};
        }
        die "Failed to add database: $@\n";
    }

    ## Store certain messages so we can output them in a desired order
    my $finalmsg = '';

    ## May want to do a test connection to the database
  TESTCONN: {

        ## Nothing else to do for flatfiles
        last TESTCONN if 'flatfile' eq $vals->{dbtype};

        ## Must have a valid type
        if ($vals->{dbtype} !~ /^(?:postgres|drizzle|mongo|mysql|oracle|redis)$/) {
            die qq{Unknown database type: $vals->{dbtype}\n};
        }

        ## Before going any further, do a test connection
        $SQL = 'SELECT bucardo.db_getconn(?)';
        $sth = $dbh->prepare($SQL);
        $count = $sth->execute($item_name);
        my $dbconn = $sth->fetchall_arrayref()->[0][0];

        if ('postgres' eq $vals->{dbtype}) {

            my ($type,$dsn,$user,$pass,$ssp) = split /\n/ => $dbconn;
            my $testdbh;
            my $realuser = $user;

          CONNLOOP: {
                eval {
                    $testdbh = DBI->connect($dsn, $user, $pass, {AutoCommit=>0,RaiseError=>1,PrintError=>0});
                };
                if ($@) {
                    ## Special exception: if the user bucardo does not exist, we will try to create it
                    if ($user eq 'bucardo' and $@ =~ /FATAL.*"bucardo"/) {
                        $user = 'postgres';
                        redo CONNLOOP;
                    }
                    if ($bcargs->{force}) {
                        print "Connection test failed, but will add anyway. Error was: $@\n\n";
                    }
                    else {
                        die "Connection test failed. You can force add it with the --force argument. Error was: $@\n\n";
                    }
                }
                else {
                    ## We were able to connect the second time as the non-bucardo user
                    ## Thus, we'll now try and create the bucardo user
                    if ($realuser ne $user) {
                        if (eval { require Digest::MD5; 1 }) {
                            ## We need a password. If one was not supplied, create one
                            eval {
                                my $newpass = $pass;
                                if (! length $pass) {
                                    my @chars = split // => q!ABCDEFGHJKMNPQRSTWXYZabcdefghjkmnpqrstwxyz23456789@#$%^&*(){}[];<>./?!;
                                    $newpass = join '' => @chars[map{ rand @chars }(1..42)];
                                }
                                my $encpass = Digest::MD5::md5_hex($newpass);
                                $testdbh->do(qq{CREATE USER $realuser SUPERUSER ENCRYPTED PASSWORD '$encpass'});
                                $testdbh->commit();
                                my $extra = length $pass ? '' : " with password $newpass";
                                warn "Created superuser '$realuser'$extra\n";
                            };
                            if ($@) {
                                warn "Unable to create superuser $realuser: $@\n";
                                $bcargs->{force} or exit 1;
                            }
                        }
                    }
                    $testdbh->disconnect();

                } } ## end of CONNLOOP

        } ## end postgres

        if ('drizzle' eq $vals->{dbtype}) {

            my ($type,$dsn,$user,$pass) = split /\n/ => $dbconn;

            my $found = 0;
            eval {
                require DBD::drizzle;
                $found = 1;
            };
            if (!$found) {
                die "Cannot add unless the DBD::drizzle module is available\n";
            }

            my $testdbh;
            $found = 0;
            eval {
                $testdbh = DBI->connect($dsn, $user, $pass, {AutoCommit=>0,RaiseError=>1,PrintError=>0});
                $found = 1;
            };
            if (! $found) {
                die "Drizzle connection test failed. You can force add it with the --force argument. Error was: $@\n\n";
            }

            $testdbh->disconnect();

        } ## end drizzle

        if ('mongo' eq $vals->{dbtype}) {
            my $found = 0;
            eval {
                require MongoDB;
                $found = 1;
            };
            if (!$found) {
                die "Cannot add unless the MongoDB perl driver is available\n";
            }

            my $testdbh;
            $found = 0;
            my $dsn = {};
            for my $line (split /\n/ => $dbconn) {
                next if $line !~ /(\w+):\s+(.+)/;
                $dsn->{$1} = $2;
            }
            eval {
                $testdbh = MongoDB::Connection->new($dsn);
                $found = 1;
            };
            if (! $found) {
                warn Dumper $dsn;
                die qq{Connection to mongodb failed: $@\n};
            }

        } ## end of mongo

        if ('mysql' eq $vals->{dbtype}) {

            my ($type,$dsn,$user,$pass) = split /\n/ => $dbconn;

            my $found = 0;
            eval {
                require DBD::mysql;
                $found = 1;
            };
            if (!$found) {
                die "Cannot add unless the DBD::mysql module is available\n";
            }

            my $testdbh;
            $found = 0;
            eval {
                $testdbh = DBI->connect($dsn, $user, $pass, {AutoCommit=>0,RaiseError=>1,PrintError=>0});
                $found = 1;
            };
            if (! $found) {
                die "MySQL connection test failed. You can force add it with the --force argument. Error was: $@\n\n";
            }

            $testdbh->disconnect();

        } ## end mysql

        if ('oracle' eq $vals->{dbtype}) {

            my ($type,$dsn,$user,$pass) = split /\n/ => $dbconn;

            my $found = 0;
            eval {
                require DBD::Oracle;
                $found = 1;
            };
            if (!$found) {
                die "Cannot add unless the DBD::Oracle module is available\n";
            }

            my $testdbh;
            $found = 0;
            eval {
                $testdbh = DBI->connect($dsn, $user, $pass, {AutoCommit=>0,RaiseError=>1,PrintError=>0});
                $found = 1;
            };
            if (! $found) {
                die "Oracle connection test failed. You can force add it with the --force argument. Error was: $@\n\n";
            }

            $testdbh->disconnect();

        } ## end oracle

        if ('redis' eq $vals->{dbtype}) {
            my $found = 0;
            eval {
                require Redis;
                $found = 1;
            };
            if (!$found) {
                die "Cannot add unless the Redis perl driver is available\n";
            }

            my $testdbh;
            $found = 0;
            my $tempdsn = {};
            for my $line (split /\n/ => $dbconn) {
                next if $line !~ /(\w+):\s+(.+)/;
                $tempdsn->{$1} = $2;
            }
            my $server;
            if (exists $tempdsn->{host}) {
                $server = $tempdsn->{host};
            }
            if (exists $tempdsn->{port}) {
                $server .= ":$tempdsn->{port}";
            }
            my @dsn;
            if (defined $server) {
                push @dsn => 'server', $server;
            }
            eval {
                $testdbh = Redis->new(@dsn);
                $found = 1;
            };
            if (! $found) {
                warn Dumper \@dsn;
                die qq{Connection to redis failed: $@\n};
            }

        } ## end of redis

    } ## end of TESTCONN

    ## If we got a group, process that as well
    if (exists $extra->{dbgroup}) {
        my $gname = $extra->{dbgroup};
        ## We need to store this away as the function below changes the global hash
        my $isnew = exists $DBGROUP->{$gname};

        my ($newgroup, $newrole) = add_db_to_group($item_name, $gname);
        if (! $isnew) {
            $finalmsg .= qq{Created database group "$newgroup"\n};
        }
        $finalmsg .= qq{Added database "$item_name" to group "$newgroup" as $newrole\n};
    }

    ## Adjust the db name so add_all_* can use it
    $bcargs->{db} = $item_name;

    ## Add in all tables for this database
    $finalmsg .= add_all_tables() if grep /addalltab/i, @nouns;

    ## Add in all sequences for this database
    $finalmsg .= add_all_sequences() if grep /addallseq/i, @nouns;

    if (!$QUIET) {
        print qq{Added database "$item_name"\n};
        $finalmsg and print $finalmsg;
    }

    confirm_commit();

    return;

} ## end of add_database


sub remove_database {

    ## Remove one or more entries from the bucardo.db table
    ## Use the --force argument to clear out related tables and groups
    ## Arguments: one or more
    ## 1+ Name of a database
    ## Returns: undef
    ## Example: bucardo remove db nyc1 nyc2 --force

    ## Grab our generic usage message
    my $usage = usage('remove_database');

    ## Must have at least one name
    if (!@nouns) {
        warn "$usage\n";
        exit 1;
    }

    ## Make sure all named databases exist
    for my $name (@nouns) {
        if (! exists $DB->{$name}) {
            my $foo = Dumper $DB;
            die qq{No such database: $name ($foo)\n};
        }
    }

    ## Prepare the SQL to delete each database
    $SQL = 'DELETE FROM bucardo.db WHERE name = ?';
    $sth = $dbh->prepare($SQL);

    ## Loop through and attempt to delete each given database
    for my $name (@nouns) {
        ## Wrap in an eval so we can handle known exceptions
        eval {
            $sth->execute($name);
        };
        if ($@) {
            if ($bcargs->{force} and $@ =~ /"goat_db_fk"|"dbmap_db_fk"/) {
                $QUIET or warn qq{Dropping all tables and dbgroups that reference database "$name"\n};
                $dbh->rollback();
                $dbh->do('DELETE FROM bucardo.goat WHERE db = ' . $dbh->quote($name));
                $dbh->do('DELETE FROM bucardo.dbmap WHERE db = ' . $dbh->quote($name));
                ## Try again
                eval {
                    $sth->execute($name);
                };
            }

            ## We've failed: output a reasonable message when possible
            if ($@ =~ /"goat_db_fk"/) {
                die qq{Cannot delete database "$name": must remove all tables that reference it first (try --force)\n};
            }
            if ($@ =~ /"dbmap_db_fk"/) {
                die qq{Cannot delete database "$name": must remove all dbmap references first (try --force)\n};
            }
            $@ and die qq{Could not delete database "$name"\n$@\n};
        }
    }

    for my $name (@nouns) {
        $QUIET or print qq{Removed database "$name"\n};
    }

    confirm_commit();

    return;

} ## end of remove_database


sub update_database {

    ## Update one or more databases
    ## This may modify the bucardo.db, bucardo.dbgroup, and bucardo.dbmap tables
    ## Arguments: two plus
    ## 1. Name of the database to update. Can be "all" and can have wildcards
    ## 2+ What exactly we are updating.
    ## Returns: undef
    ## Example: bucardo update db nyc1 port=6543 group=nycservers:source,globals

    ## Grab our generic usage message
    my $usage = usage('update_database');

    my $name = shift;
    my @actions = @_;

    if (! @actions) {
        print "$usage\n";
        exit 1;
    }

    ## Recursively call ourselves for wildcards and 'all'
    return if ! check_recurse($DB, $name, @actions);

    ## Make sure this database exists!
    if (! exists $DB->{$name}) {
        die qq{Could not find a database named "$name"\nUse 'list dbs' to see all available.};
    }

    ## Everything is a name=value setting after this point
    ## We will ignore and allow noise word "set"
    for my $arg (@actions) {
        next if $arg =~ /set/i;
        next if $arg =~ /\w+=\w+/o;
        print "$usage\n";
        exit 1;
    }

    ## Change the arguments into a hash
    my $args = process_args(join ' ' => @actions);

    ## Track what changes we made
    my %change;

    ## Walk through and handle each argument pair
    for my $setting (sort keys %$args) {

        ## Change the name to a more standard form, to better figure out what they really mean
        ## This also excludes all non-alpha characters
        my $newname = transform_name($setting);

        ## Exclude ones that cannot / should not be changed (e.g. cdate)
        if (exists $column_no_change{$newname}) {
            print "Sorry, the value of $setting cannot be changed\n";
            exit 1;
        }

        ## Standardize the values as well
        my $value = $args->{$setting};
        my $newvalue = transform_value($value);

        ## Handle all the non-standard columns
        if ($newname =~ /^group/) {

            ## Track the changes and publish at the end
            my @groupchanges;

            ## Grab the current hash of groups
            my $oldgroup = $DB->{$name}{group} || '';

            ## Keep track of what groups they end up in, so we can remove as needed
            my %donegroup;

            ## Break apart into individual groups
            for my $fullgroup (split /\s*,\s*/ => $newvalue) {

                my ($group,$role,$extra) = extract_name_and_role($fullgroup);

                ## Note that we've found this group
                $donegroup{$group}++;

                ## Does this group exist?
                if (! exists $DBGROUP->{$group}) {
                    create_dbgroup($group);
                    push @groupchanges => qq{Created database group "$group"};
                }

                ## Are we a part of it already?
                if ($oldgroup and exists $oldgroup->{$group}) {

                    ## Same role?
                    my $oldrole = $oldgroup->{$group}{role};
                    if ($oldrole eq $role) {
                        $QUIET or print qq{No change: database "$name" already belongs to group "$group" as $role\n};
                    }
                    else {
                        change_db_role($role,$group,$name);
                        push @groupchanges => qq{Changed role for database "$name" in group "$group" from $oldrole to $role};
                    }
                }
                else {
                    ## We are not a part of this group yet
                    add_db_to_group($name, "$group:$role");
                    push @groupchanges => qq{Added database "$name" to group "$group" as $role};
                }

                ## Handle any extra modifiers
                if (keys %$extra) {
                    update_dbmap($name, $group, $extra);
                    my $list = join ',' => map { "$_=$extra->{$_}" } sort keys %$extra;
                    push @groupchanges => qq{For database "$name" in group "$group", set $list};
                }

            } ## end each group specified

            ## See if we are removing any groups
            if ($oldgroup) {
                for my $old (sort keys %$oldgroup) {
                    next if exists $donegroup{$old};

                    ## Remove this database from the group, but do not remove the group itself
                    remove_db_from_group($name, $old);
                    push @groupchanges => qq{Removed database "$name" from group "$old"};
                }
            }

            if (@groupchanges) {
                for (@groupchanges) {
                    chomp;
                    $QUIET or print "$_\n";
                }
                confirm_commit();
            }

            ## Go to the next setting
            next;

        } ## end of 'group' adjustments

        ## This must exist in our hash
        if (! exists $DB->{$name}{$newname}) {
            print qq{Cannot change "$newname"\n};
            next;
        }
        my $oldvalue = $DB->{$name}{$newname};

        ## Has this really changed?
        if ($oldvalue eq $newvalue) {
            print "No change needed for $newname\n";
            next;
        }

        ## Add to the queue. Overwrites previous ones
        $change{$newname} = [$oldvalue, $newvalue];

    } ## end each setting

    ## If we have any changes, attempt to make them all at once
    if (%change) {
        my $SQL = 'UPDATE bucardo.db SET ';
        $SQL .= join ',' => map { "$_=?" } sort keys %change;
        $SQL .= ' WHERE name = ?';
        my $sth = $dbh->prepare($SQL);
        eval {
            $sth->execute((map { $change{$_}[1] } sort keys %change), $name);
        };
        if ($@) {
            $dbh->rollback();
            $dbh->disconnect();
            print "Sorry, failed to update the bucardo.db table. Error was:\n$@\n";
            exit 1;
        }

        for my $item (sort keys %change) {
            my ($old,$new) = @{ $change{$item} };
            print "Changed bucardo.db $item from $old to $new\n";
        }

        confirm_commit();
    }

    return;

} ## end of update_database


sub list_databases {

    ## Show information about all or some subset of the bucardo.db table
    ## Arguments: zero or more
    ## 1+ Databases to view. Can be "all" and can have wildcards
    ## Returns: undef
    ## Example: bucardo list db sale%

    ## Grab our generic usage message
    my $usage = usage('list_databases');

    ## Might be no databases yet
    if (! keys %$DB) {
        print "No databases have been added yet\n";
        exit 1;
    }

    ## If not doing all, keep track of which to show
    my %matchdb;

    for my $term (@nouns) {

        ## Special case for all: same as no nouns at all, so simply remove them!
        if ($term =~ /\ball\b/i) {
            undef %matchdb;
            undef @nouns;
            last;
        }

        ## Check for wildcards
        if ($term =~ s/[*%]/.*/) {
            for my $name (keys %$DB) {
                $matchdb{$name} = 1 if $name =~ /$term/;
            }
            next;
        }

        ## Must be an exact match
        for my $name (keys %$DB) {
            $matchdb{$name} = 1 if $name eq $term;
        }

    } ## end each term

    ## No matches?
    if (@nouns and ! keys %matchdb) {
        print "No matching databases found\n";
        exit 1;
    }

    ## We only show the type if they are different
    my %typecount;

    ## Figure out the length of each item for a pretty display
    my ($maxdb,$maxtype,$maxstat,$maxlim1,$maxlim2,$showlim) = (1,1,1,1,1,0);
    for my $name (sort keys %$DB) {
        next if @nouns and ! exists $matchdb{$name};
        my $info = $DB->{$name};
        $typecount{$info->{dbtype}}++;
        $maxdb   = length $info->{name} if length $info->{name} > $maxdb;
        $maxtype = length $info->{dbtype} if length $info->{dbtype} > $maxtype;
        $maxstat = length $info->{status} if length $info->{status} > $maxstat;
        $maxlim1 = length $info->{sourcelimit} if length $info->{sourcelimit} > $maxlim1;
        $maxlim2 = length $info->{targetlimit} if length $info->{targetlimit} > $maxlim2;
        $showlim = 1 if $info->{sourcelimit} or $info->{targetlimit};
    }

    ## Do we show types?
    my $showtypes = keys %typecount > 1 ? 1 : 0;

    ## Now do the actual printing
    for my $name (sort keys %$DB) {
        next if @nouns and ! exists $matchdb{$name};
        my $info = $DB->{$name};
        my $type = sprintf 'Type: %-*s  ',
            $maxtype, $info->{dbtype};
        printf 'Database: %-*s  %sStatus: %-*s  ',
            $maxdb, $info->{name},
            $showtypes ? $type : '',
            $maxstat, $info->{status};
        if ($showlim) {
            printf 'Limits: %-*s/%-*s  ',
                $maxlim1, $info->{sourcelimit},
                $maxlim2, $info->{targetlimit},
        }
        my $showhost = length $info->{dbhost} ? " -h $info->{dbhost}" : '';
        my $dbtype = $info->{dbtype};
        if ($dbtype eq 'postgres') {
            print "Conn: psql -p $info->{dbport} -U $info->{dbuser} -d $info->{dbname}$showhost";
            if (! $info->{server_side_prepares}) {
                print ' (SSP is off)';
            }
        }
        if ($dbtype eq 'drizzle') {
            my $showport = (length $info->{dbport} and $info->{dbport} != 3306)
                ? " --port $info->{dbport}" : '';
            printf "Conn: drizzle -u %s -D %s%s%s",
                $info->{dbuser},
                $info->{dbname},
                $showhost,
                $showport;
        }
        if ($dbtype eq 'flatfile') {
            print "Prefix: $info->{dbname}";
        }
        if ($dbtype eq 'mongo') {
            if (length $info->{dbhost}) {
                print "Host: $info->{dbhost}";
            }
        }
        if ($dbtype eq 'mysql') {
            my $showport = (length $info->{dbport} and $info->{dbport} != 3306)
                ? " --port $info->{dbport}" : '';
            printf "Conn: mysql -u %s -D %s%s%s",
                $info->{dbuser},
                $info->{dbname},
                $showhost,
                $showport;
        }
        if ($dbtype eq 'oracle') {
            printf "Conn: sqlplus %s%s",
                $info->{dbuser},
                $showhost ? qq{\@$showhost} : '';
        }
        if ($dbtype eq 'redis') {
            my $server = '';
            if (length $info->{dbhost}) {
                $server .= $info->{dbhost};
            }
            if (length $info->{dbport}) {
                $server .= ":$info->{dbport}";
            }
            if ($server) {
                $server = "server=$server";
                print "Conn: $server";
            }
        }

        print "\n";

        if ($VERBOSE) {

            ## Which database groups is this a member of?
            if (exists $info->{group}) {
                for my $group (sort keys %{ $info->{group} }) {
                    my $i = $info->{group}{$group};
                    my $role = $i->{role};
                    my $gang = $i->{gang};
                    my $pri = $i->{priority};
                    print "  Belongs to database group $group ($role)  Gang:$gang";
                    $pri and print "  Priority:$pri";
                    print "\n";
                }
            }

            ## Which syncs are using it (source vs. target)
            if (exists $info->{sourcesync}) {
                print '  Used as source in syncs: ';
                print join ', ' => sort keys %{ $info->{sourcesync} };
                print "\n";
            }
            if (exists $info->{targetsync}) {
                print '  Used as target in syncs: ';
                print join ', ' => sort keys %{ $info->{targetsync} };
                print "\n";
            }

            $VERBOSE >= 2 and show_all_columns($info);
        }
    }

    exit 0;

} ## end of list_databases


##
## Database-group-related subroutines: add, remove, update, list
##

sub add_dbgroup {

    ## Add one or more database groups. Inserts to the bucardo.dbgroup table
    ## May also insert to the bucardo.dbmap table
    ## Arguments: one plus
    ## 1. The name of the group we are creating
    ## 2+ Databases to add to this group, with optional role information attached
    ## Returns: undef
    ## Example: bucardo add dbgroup nycservers nyc1:source nyc2:source lax1

    ## Grab our generic usage message
    my $usage = usage('add_dbgroup');

    my $name = shift @nouns || '';

    ## Must have a name
    if (!length $name) {
        warn "$usage\n";
        exit 1;
    }

    ## Create the group if it does not exist
    if (! exists $DBGROUP->{$name}) {
        create_dbgroup($name);
        $QUIET or print qq{Created database group "$name"\n};
    }

    ## Add all these databases to the group
    for my $fulldb (@nouns) {

        ## Figure out the optional role
        my ($db,$role) = extract_name_and_role($fulldb);

        ## This database must exist!
        if (! exists $DB->{$db}) {
            print qq{The database "$db" does not exist\n};
            exit 1;
        }

        add_db_to_group($db, "$name:$role");

        $QUIET or print qq{Added database "$db" to group "$name" as $role\n};
    }

    confirm_commit();

    return;

} ## end of add_dbgroup


sub remove_dbgroup {

    ## Remove one or more entries from the bucardo.dbgroup table
    ## Arguments: one or more
    ## 1+ Name of a database group
    ## Returns: undef
    ## Example: bucardo remove dbgroup sales

    ## Grab our generic usage message
    my $usage = usage('remove_dbgroup');

    ## Must have at least one name
    if (!@nouns) {
        warn "$usage\n";
        exit 1;
    }

    ## Make sure all the groups exist
    for my $name (@nouns) {
        if (! exists $DBGROUP->{$name}) {
            die qq{No such database group: $name\n};
        }
    }

    ## Prepare the SQL to delete each group
    $SQL = q{DELETE FROM bucardo.dbgroup WHERE name = ?};
    $sth = $dbh->prepare($SQL);

    for my $name (@nouns) {
        ## Wrap in an eval so we can handle known exceptions
        eval {
            $sth->execute($name);
        };
        if ($@) {
            if ($@ =~ /"sync_dbs_fk"/) {
                if ($bcargs->{force}) {
                    $QUIET or warn qq{Dropping all syncs that reference the dbgroup "$name"\n};
                    $dbh->rollback();
                    $dbh->do('DELETE FROM bucardo.sync WHERE dbs = ' . $dbh->quote($name));
                    eval {
                        $sth->execute($name);
                    };
                    goto NEND if ! $@;
                }
                else {
                    die qq{Cannot remove database group "$name": it is being used by one or more syncs\n};
                }
            }
            die qq{Could not delete database group "$name"\n$@\n};
        }
          NEND:
        $QUIET or print qq{Removed database group "$name"\n};
    }

    confirm_commit();

    return;

} ## end of remove_dbgroup


sub update_dbgroup {

    ## Update one or more database groups
    ## This may modify the bucardo.dbgroup and bucardo.dbmap tables
    ## Arguments: two or more
    ## 1. Group to be updated
    ## 2. Databases to be adjusted, or name change request (name=newname)
    ## Returns: undef
    ## Example: bucardo update dbgroup sales A:slave

    ## Grab our generic usage message
    my $usage = usage('update_dbgroup');

    my $name = shift;
    my @actions = @_;

    if (! @actions) {
        print "$usage\n";
        exit 1;
    }

    ## Recursively call ourselves for wildcards and 'all'
    return if ! check_recurse($DBGROUP, $name, @actions);

    ## Make sure this database group exists!
    if (! exists $DBGROUP->{$name}) {
        die qq{Could not find a database group named "$name"\nUse 'list dbgroups' to see all available.};
    }

    ## From this point on, we have either:
    ## 1. A rename request
    ## 2. A database to add/modify

    ## Track dbs and roles
    my %dblist;

    ## Track if we call confirm_commit or not
    my $changes = 0;


    for my $action (@actions) {
        ## New name for this group?
        if ($action =~ /name=(.+)/) {
            my $newname = $1;
            if ($newname !~ /^$re_dbgroupname$/) {
                die qq{Invalid database group name "$newname"\n};
            }
            next if $name eq $newname; ## Duh
            $SQL = 'UPDATE bucardo.dbgroup SET name=? WHERE name=?';
            $sth = $dbh->prepare($SQL);
            $sth->execute($newname, $name);
            $QUIET or print qq{Changed database group name from "$name" to "$newname"\n};
            $changes++;
            next;
        }

        ## Assume the rest is databases to modify

        ## Default role is always target
        my ($db,$role) = extract_name_and_role($action);
        $dblist{$db} = $role;
    }

    ## Leave now if no databases to handle
    if (! %dblist) {
        $changes and confirm_commit();
        exit 0;
    }

    ## The old list of databases:
    my $oldlist = $DBGROUP->{$name}{db} || {};

    ## Walk through the old and see if any were changed or removed
    for my $db (sort keys %$oldlist) {
        if (! exists $dblist{$db}) {
            remove_db_from_group($db, $name);
            $QUIET or print qq{Removed database "$db" from group "$name"\n};
            $changes++;
            next;
        }
        my $oldrole = $oldlist->{$db}{role};
        my $newrole = $dblist{$db};
        if ($oldrole ne $newrole) {
            change_db_role($newrole, $db, $name);
            $QUIET or print qq{Changed role of database "$db" in group "$name" from $oldrole to $newrole\n};
            $changes++;
        }
    }

    ## Walk through the new and see if any are truly new
    for my $db (sort keys %dblist) {
        next if exists $oldlist->{$db};
        my $role = $dblist{$db};
        add_db_to_group($db, "$name:$role");
        $QUIET or print qq{Added database "$db" to group "$name" as $role\n};
        $changes++;
    }

    confirm_commit() if $changes;

    return;

} ## end of update_dbgroup


sub list_dbgroups {

    ## Show information about all or some subset of the bucardo.dbgroup table
    ## Arguments: zero or more
    ## 1+ Groups to view. Can be "all" and can have wildcards
    ## Returns: undef
    ## Example: bucardo list dbgroups

    ## Grab our generic usage message
    my $usage = usage('list_dbgroups');

    ## Might be no groups yet
    if (! keys %$DBGROUP) {
        print "No database groups have been added yet\n";
        exit 1;
    }

    ## If not doing all, keep track of which to show
    my %matchdbg;

    for my $term (@nouns) {

        ## Special case for all: same as no nouns at all, so simply remove them!
        if ($term =~ /\ball\b/i) {
            undef %matchdbg;
            undef @nouns;
            last;
        }

        ## Check for wildcards
        if ($term =~ s/[*%]/.*/) {
            for my $name (keys %$DBGROUP) {
                $matchdbg{$name} = 1 if $name =~ /$term/;
            }
            next;
        }

        ## Must be an exact match
        for my $name (keys %$DBGROUP) {
            $matchdbg{$name} = 1 if $name eq $term;
        }

    } ## end each term

    ## No matches?
    if (@nouns and ! keys %matchdbg) {
        print "No matching database groups found\n";
        exit 1;
    }

    ## Figure out the length of each item for a pretty display
    my ($maxlen) = (1);
    for my $name (sort keys %$DBGROUP) {
        next if @nouns and ! exists $matchdbg{$name};
        my $info = $DBGROUP->{$name};
        $maxlen = length $info->{name} if length $info->{name} > $maxlen;
    }

    ## Print it
    for my $name (sort keys %$DBGROUP) {
        next if @nouns and ! exists $matchdbg{$name};
        my $info = $DBGROUP->{$name};
        ## Does it have associated databases?
        my $dbs = '';
        if (exists $DBGROUP->{$name}{db}) {
            $dbs = '  Members:';
            for my $dbname (sort keys %{ $DBGROUP->{$name}{db} }) {
                my $i = $DBGROUP->{$name}{db}{$dbname};
                $dbs .= " $dbname:$i->{role}";
                ## Only show the gang if this group is using multiple gangs
                if ($DBGROUP->{$name}{gangs} >= 2) {
                    $dbs .= ":gang=$i->{gang}";
                }
                ## Only show the priority if <> 0
                if ($i->{priority} != 0) {
                    $dbs .= ":pri=$i->{priority}";
                }
            }
        }
        printf "Database group: %-*s%s\n",
            $maxlen, $name, $dbs;
        $VERBOSE >= 2 and show_all_columns($info);
    }

    exit 0;

} ## end of list_dbgroups


##
## Table-related subroutines: add, remove, update, list
##

sub add_table {

    ## Add one or more tables. Inserts to the bucardo.goat table
    ## May also update the bucardo.herd and bucardo.herdmap tables
    ## Arguments: one or more
    ## 1+ Names of tables to be added
    ## Returns: undef
    ## Example: bucardo add table pgbench_accounts foo% myschema.abc

    ## Grab our generic usage message
    my $usage = usage('add_table');

    ## Must have at least one table
    if (! @nouns) {
        warn "$usage\n";
        exit 1;
    }

    ## Inputs and aliases, database column name, flags, default
    my $validcols = q{
        db                       db                   0                null
        ping                     ping                 TF               null
        rebuild_index            rebuild_index        numeric          null
        standard_conflict        standard_conflict    0                null
        analyze_after_copy       analyze_after_copy   TF               null
        herd                     herd                 0                skip
    };

    my ($dbcols,$cols,$phs,$vals,$extra)
        = process_simple_args({cols => $validcols, list => \@nouns, usage => $usage});

    ## Loop through all the args and attempt to add the tables
    ## This returns a hash with the following keys: relations, match, nomatch
    my $goatlist = get_goat_ids({args => \@nouns, dbcols => $dbcols});

    ## The final output. Store it up all at once for a single QUIET check
    my $msg = '';

    ## We will be nice and indicate anything that did not match
    if (keys %{ $goatlist->{nomatch} }) {
        $msg .= "Did not find matches for the following terms:\n";
        for (sort keys %{ $goatlist->{nomatch} }) {
            $msg .= "  $_\n";
        }
    }

    ## Now we need to output which ones were recently added
    if (keys %{ $goatlist->{new} }) {
        $msg .= "Added the following tables:\n";
        for (sort keys %{ $goatlist->{new} }) {
            $msg .= "  $_\n";
        }
    }

    ## If they requested a herd and it does not exist, create it
    if (exists $extra->{herd}) {
        my $herdname = $extra->{herd};
        if (! exists $HERD->{$herdname}) {
            $SQL = 'INSERT INTO bucardo.herd(name) VALUES(?)';
            $sth = $dbh->prepare($SQL);
            $sth->execute($herdname);
            $msg .= qq{Created the herd named "$herdname"\n};
        }
        ## Now load all of these tables into this herd
        $SQL = 'INSERT INTO bucardo.herdmap (herd,priority,goat) VALUES (?,?,'
            . q{ (SELECT id FROM goat WHERE schemaname||'.'||tablename=? AND db=?))};

        $sth = $dbh->prepare($SQL);

        ## Which tables were already in the herd, and which were just added
        my (@oldnames,@newnames);

        for my $name (sort keys %{ $goatlist->{relations} }) {
            ## Is it already part of this herd?
            if (exists $HERD->{goat}{$name}) {
                push @oldnames => $name;
                next;
            }
            my $db = $goatlist->{relations}{$name}{goat}{db};

            my $pri = 0;

            $count = $sth->execute($herdname,$pri,$name, $db);

            push @newnames => $name;
        }

        if (@oldnames) {
            $msg .= qq{The following tables were already in the herd "$herdname":\n};
            for (@oldnames) {
                $msg .= "  $_\n";
            }
        }

        if (@newnames) {
            $msg .= qq{The following tables are now part of the herd "$herdname":\n};
            for (sort numbered_relations @newnames) {
                $msg .= "  $_\n";
            }
        }

    } ## end if herd

    if (!$QUIET) {
        print $msg;
    }

    confirm_commit();

    return;

} ## end of add_table


sub remove_table {

    ## Usage: remove table tablename [t2 t3 ...]
    ## Wildcards?

    my $usage = usage('remove_table');

    if (!@nouns) {
        warn "$usage\n";
        exit 1;
    }

    ## Prepare our SQL
    $SQL = q{DELETE FROM bucardo.goat WHERE schemaname||'.'||tablename = ?};
    $sth = $dbh->prepare($SQL);

    for my $name (@nouns) {
        if ($name =~ /^\w[\w\d]*\.\w[\w\d]*$/) {
            if (! exists $GOAT->{$name}) {
                print qq{No such table: $name\n};
            }
            eval {
                $sth->execute($name);
            };
            if ($@) {
                die qq{Could not delete goat "$name"\n$@\n};
            }
        }
        else {
            die qq{Please use the full schema.table name\n};
        }
    }

    print "Removed the following tables:\n";
    for my $name (sort numbered_relations @nouns) {
        print qq{  $name\n};
    }

    confirm_commit();

    exit 0;

} ## end of remove_table


##
## Herd-related subroutines: add, remove, update, list
##

sub add_herd {

    ## Add a herd. Inserts to the bucardo.herd table
    ## May also insert to the bucardo.herdmap and bucardo.goat tables
    ## Arguments: one or more
    ## 1. Name of the herd
    ## 2+ Names of tables or sequences to add. Can have wildcards
    ## Returns: undef
    ## Example: bucardo add herd foobar tab1 tab2

    ## Grab our generic usage message
    my $usage = usage('add_herd');

    my $herdname = shift @nouns || '';

    ## Must have a name
    if (!length $herdname) {
        warn "$usage\n";
        exit 1;
    }

    ## Create the herd if it does not exist
    if (exists $HERD->{$herdname}) {
        print qq{Herd "$herdname" already exists\n};
    }
    else {
        create_herd($herdname);
        $QUIET or print qq{Created herd "$herdname"\n};
    }

    ## Everything else is tables or sequences to add to this herd

    ## How many arguments were we given?
    my $nouncount = @nouns;

    ## No sense going on if no nouns!
    if (! $nouncount) {
        confirm_commit();
        return undef;
    }

    ## Get the list of all requested tables, adding as needed
    my $goatlist = get_goat_ids({args => \@nouns});

    ## The final output. Store it up all at once for a single QUIET check
    my $msg = '';

    ## We will be nice and indicate anything that did not match
    if (keys %{ $goatlist->{nomatch} }) {
        $msg .= "Did not find matches for the following terms:\n";
        for (sort keys %{ $goatlist->{nomatch} }) {
            $msg .= "  $_\n";
        }
    }

    ## Now we need to output which ones were recently added
    if (keys %{ $goatlist->{new} }) {
        $msg .= "Added the following tables:\n";
        for (sort keys %{ $goatlist->{new} }) {
            $msg .= "  $_\n";
        }
    }


    ## Now load all of these tables into this herd
    $SQL = 'INSERT INTO bucardo.herdmap (herd,priority,goat) VALUES (?,?,'
        . q{ (SELECT id FROM goat WHERE schemaname||'.'||tablename=? AND db=?))};

    $sth = $dbh->prepare($SQL);

    my (@oldnames, @newnames);

    for my $name (sort keys %{ $goatlist->{relations} }) {
        ## Is it already part of this herd?
        if (exists $HERD->{goat}{$name}) {
            push @oldnames => $name;
            next;
        }
        my $db = $goatlist->{relations}{$name}{goat}{db};

        my $pri = 0;

        $count = $sth->execute($herdname,$pri,$name, $db);

        push @newnames => $name;
    }

    if (@oldnames) {
        $msg .= qq{The following tables were already in the herd "$herdname":\n};
        for (@oldnames) {
            $msg .= "  $_\n";
        }
    }

    if (@newnames) {
        $msg .= qq{The following tables are now part of the herd "$herdname":\n};
        for (@newnames) {
            $msg .= "  $_\n";
        }
    }

    if (!$QUIET) {
        print $msg;
    }

    confirm_commit();

    return;

} ## end of add_herd


sub remove_herd {

    ## Usage: remove herd herdname [herd2 herd3 ...]

    my $usage = usage('remove_herd');

    if (!@nouns) {
        warn "$usage\n";
        exit 1;
    }

    my $herd = $global{herd};

    for my $name (@nouns) {
        if (! exists $herd->{$name}) {
            die qq{No such herd: $name\n};
        }
    }

    $SQL = 'DELETE FROM bucardo.herd WHERE name = ?';
    $sth = $dbh->prepare($SQL);
    for my $name (@nouns) {
        eval {
            $sth->execute($name);
        };
        if ($@) {
            if ($@ =~ /"sync_source_herd_fk"/) {
                die qq{Cannot delete herd "$name": must remove all syncs that reference it first\n};
            }
            die qq{Could not delete herd "$name"\n$@\n};
        }
    }

    for my $name (@nouns) {
        print qq{Removed herd "$name"\n};
    }

    $dbh->commit();

    exit 0;

} ## end of remove_herd


sub update_herd {

} ## end of update_herd

sub list_herds {

    ## Show information about all or some subset of the 'herd' table

    my $usage = usage('list_herds');

    ## Any nouns are filters against the whole list
    my $clause = generate_clause({col => 'name', items => \@nouns});
    my $WHERE = $clause ? "WHERE $clause" : '';
    $SQL = "SELECT * FROM bucardo.herd $WHERE ORDER BY name";
    $sth = $dbh->prepare($SQL);
    $count = $sth->execute();
    if ($count < 1) {
        $sth->finish();
        printf "There are no%s entries in the 'herd' table.\n",
            $WHERE ? ' matching' : '';
        exit 1;
    }
    $info = $sth->fetchall_arrayref({});

    ## Get sizing information
    my $maxlen = 1;
    for my $row (@$info) {
        $maxlen = length $row->{name} if length $row->{name} > $maxlen;
    }

    ## Figure out which goats are in each of these herds
    for my $row (@$info) {
        my $name = $row->{name};
        my $h = $global{herd}{$name};
        printf 'Herd: %-*s  DB: %s ',
            $maxlen, $name, $h->{db};
        ## Got goats?
        if (exists $h->{goat}) {
            print ' Members: ';
            print join ', ' => sort keys %{ $h->{goat} };
        }
        ## Got syncs?
        if (exists $h->{sync}) {
            print "\n  Used in syncs: ";
            print join ', ' => sort keys %{$h->{sync}};
        }
        print "\n";
        $VERBOSE >= 2 and show_all_columns($row);
    }


    exit 0;

} ## end of list_herds






































sub stop {

    ## Attempt to stop Bucardo

    append_reason_file('stop');

    print "Creating $STOPFILE ... " unless $QUIET;
    stop_bucardo();
    print "Done\n" unless $QUIET;

    exit 0 if $verb eq 'stop';

    return;

} ## end of stop


sub reload_config {

    ## Reload configuration settings from the DB, restart all controllers and kids
    for (@nouns) {
        if (/^\d+$/) {
            $adverb = $1;
            last;
        }
    }

    $QUIET or print q{Forcing Bucardo to reload the bucardo_config table};

    my $done = 'bucardo_reload_config_finished';
    $dbh->do('NOTIFY bucardo_reload_config');
    if (defined $adverb) {
        print '...';
        $dbh->do("LISTEN $done");
    }
    $dbh->commit();

    if (!defined $adverb) {
        print "\n";
        exit 0;
    }
    sleep 0.1;
    wait_for_notice($dbh, $done);
    print "DONE!\n";

    exit 0;

} ## end of reload_config


sub reload {

    ## Ask for one or more syncs to be reloaded

    my $usage = usage('reload');

    if (!@nouns) {
        warn "$usage\n";
        exit 1;
    }

    for my $syncname (@nouns) {
        next if $syncname eq 'sync'; ## Allows $0 reload sync foobar

        ## Make sure this sync exists
        $SQL = 'SELECT status FROM bucardo.sync WHERE name = ?';
        $sth = $dbh->prepare($SQL);
        $count = $sth->execute($syncname);
        if ($count != 1) {
            warn "Invalid sync: $syncname\n";
            $sth->finish();
            next;
        }
        my $status = $sth->fetch()->[0];
        if ($status ne 'active') {
            warn qq{Cannot reload: status of sync "$syncname" is $status\n};
            next;
        }

        my $done = "bucardo_reloaded_sync_$syncname";
        print "Reloading sync $syncname...";
        $dbh->do(qq{LISTEN "$done"});
        $dbh->do(qq{NOTIFY "bucardo_reload_sync_$syncname"});
        $dbh->commit();

        sleep 0.1;
        wait_for_notice($dbh, $done);
    }

    exit 0;

} ## end of reload




sub validate {

    ## Ask for one or more syncs to be validated

    my $usage = usage('validate');

    if (!@nouns) {
        warn "$usage\n";
        exit 0;
    }

    my $synclist = $global{sync};

    my @synclist;
    if ($nouns[0] eq 'all' and ! defined $nouns[1]) {
        @synclist = sort keys %$synclist;
        if (! @synclist) {
            print "Sorry, there are no syncs to validate!\n";
            exit 0;
        }
    }
    else {
        for my $name (@nouns) {
            next if $name eq 'sync'; ## Allows $0 validate sync foobar
            if (! exists $synclist->{$name}) {
                die qq{Sorry, there is no sync named "$name"\n};
            }
            push @synclist => $name;
        }
    }

    ## Get the largest size to we can line up the dots all pretty
    my $maxsize = 1;
    for my $name (@synclist) {
        $maxsize = length $name if length $name > $maxsize;
    }
    $maxsize += 3;

    for my $name (@synclist) {
        my $done = "bucardo_validated_sync_$name";
        printf "Validating sync $name%s",
            '.' x ($maxsize - length $name);
        $dbh->do(qq{LISTEN "$done"});
        $SQL = 'SELECT validate_sync(?)';
        $sth = $dbh->prepare($SQL);
        $sth->execute($name);
        $dbh->commit();

        sleep 0.1;
        wait_for_notice($dbh, $done);
        print "DONE!\n";
    }

    exit 0;

} ## end of validate


sub update {

    ## Update some object in the database
    ## e.g. bucardo update sync foobar onetimecopy=2
    ## e.g. bucardo update sync foobar add tab1

    my $usage = usage('update');

    ## Must have at least two nouns
    if ($#nouns < 2) {
        warn "$usage\n";
        exit 1;
    }

    ## What type of thing are we updating?
    my $item = shift @nouns;

    ## Which item are we updating?
    my $name = shift @nouns;

    if ($item =~ /^s[yi]n/i) {
        update_sync($name, @nouns);
        exit;
    }

    my $info;
    my $lookupcol = 'name';
    my $tabname;
    if ($item =~ /^all$/i) {
        $tabname = $item = $name;
        $name = 'all';
    }

    if ($item =~ /^code/i or $item =~ /^custom/i) {
        $tabname = $item = 'customcode';
    }
    elsif ($item =~ /^syn/i) {
        update_sync($name, @nouns);
        exit 0;
    }
    elsif ($item =~ /^tab/i or $item =~ /^seq/i) {
        $tabname = 'goat';
        $lookupcol = 'tablename';
    }
    elsif ($item =~ /^dbg/i) {
        update_dbgroup($name, @nouns);
        exit 0;
    }
    elsif ($item =~ /^db/i or $item =~ /^datab/i) {
        update_database($name, @nouns);
        exit 0;
    }
    elsif ($item =~ /^herd/i) {
        $tabname = $item = 'herd';
    }
    else {
        die "Invalid item: must be code, db, dbgroup, herd, sequence, sync, or table.\n";
    }

    $SQL = "SELECT * FROM $tabname WHERE $lookupcol = ?";
    if ($tabname eq 'goat' and $name =~ /(.+)\.(.+)/) {
        my ($sname,$tname) = ($1,$2);
        $SQL = 'SELECT * FROM bucardo.goat WHERE schemaname=? AND tablename=?';
        if ($sname =~ s/\*//) {
            $SQL =~ s/=/~/;
        }
        if ($tname =~ s/\*//) {
            $SQL =~ s/=\?$/~?/;
        }
        $sth = $dbh->prepare($SQL);
        $count = $sth->execute($sname,$tname);
    }
    else {
        if ($name =~ s/\*//) {
            $SQL =~ s/=/~/;
        }
        $sth = $dbh->prepare($SQL);
        $count = $sth->execute($name);
    }

    ## Because both 'table' and 'tables' are valid, but we want good output:
    (my $single_item = $item) =~ s/s$//;

    if ($count < 1 and $name ne 'all') {
        $sth->finish();
        die qq{No matches found for $single_item "$name"\n};
    }

    my $pkcol = $tabname eq 'goat' ? 'id' : 'name';

    $dbh->{pg_bool_tf} = 1;
    $info = $sth->fetchall_arrayref({});

    my $validate_msg = 0;

    if ('sync' eq $item and ($nouns[0] eq 'add' or $nouns[0] eq 'remove')) {
        my $v = shift @nouns;
        die "Can only $v to one sync at a time\n" if @$info > 1;
        $info = $info->[0];
        my $miniusage = "Usage: update sync $name $v table|sequence <name(s)>\n";
        my $thing = shift @nouns or die $miniusage;
        @nouns or die $miniusage;

        my $sync = $global{sync}{$name};

        ## Grab all tables used in this sync
        my @tables = keys %{ $sync->{herd}{goat} };

        if ($v eq 'remove') {
            ## The list of tables to remove, fully qualified
            my %remove;

            ## Figure out which tables they really mean and verify they are part of the sync
            my $matches = get_arg_items(\@tables, \@nouns);

            if (! ref $matches) {
                die qq{Did not find any matching tables for "$matches" for sync "$name"\n};
            }

            ## Did we get any matches? Just in case...
            if (! keys %$matches) {
                die qq{No matching tables found to remove\n};
            }

            ## Remove each table from the herd
            my $herdname = $sync->{herd}{name};
            $SQL = 'DELETE FROM bucardo.herdmap WHERE herd = ? AND goat = ?';
            my $sth = $dbh->prepare($SQL);
            for my $fullname (sort keys %$matches) {
                my $goat = $global{goat}{$fullname}
                    or die qq{Could not find an id for table "$fullname"!\n};
                $sth->execute($herdname,$goat->{id});
                print qq{Removed from sync "$name": $goat->{reltype} "$fullname"\n};
            }
            $dbh->commit();

            ## Report if any other syncs are using these tables
            my $synclist = $global{herd}{$herdname}{sync};
            my @othersyncs = grep { $_ ne $name } keys %$synclist;
            if (@othersyncs) {
                print qq{Warning! The following syncs were also using items from the herd "$herdname":\n};
                for my $s (sort @othersyncs) {
                    print qq{  Sync "$s"\n};
                }
            }

            exit 0;

        } ## end of removing tables

        ## 'add'
        ## Must be valid known tables
        ## Auto-add ones that are not already there?
        ## Do we care if some do not match?
        ## At any rate, build a list, then add in ones that are not already part of the sync

        ## Build a list of tables we are adding.
        ## Give output about each as we process it
        ## Do not report on the same one twice.
        ## Report all success, then all failures


        ## First, find any matches for tables we already know about, in $global{goat}
        my $goatlist = get_goat_ids(@nouns);
        my $nouncount = @nouns;

        ## Figure out if we need to hit the live database to add potential tables
        ## We do not only if all nouns are of the format "a.b" and got a match
        my $goatnumber = keys %{ $goatlist->{relations} };

        ## Are there any not in the given format?
        my $searchlivetables = grep { ! /^\w+\.\w+$/ } @nouns;


        if (! $searchlivetables) {
            ## All are in the x.y format, but did we match them all?
            if ($nouncount != $goatnumber) {
                $searchlivetables = 1;
            }
        }

        my $livenumber = 0;
        my $livelist;
        if ($searchlivetables) {
            print "Searching live tables for matches to the nouns\n";
            ## Which database should we look in?
            my $sourcedb = $sync->{herd}{db};
            $livelist = get_live_goat_ids($sourcedb, @nouns);
            $livenumber = keys %{ $livelist->{relations} };
        }

        print "Found goat matches: $goatnumber\n";
        print "Found live matches: $livenumber\n";
        print "Nouns to scan: $nouncount\n";

        ## We now have two lists both containing hash with keys as the schema.table names
        ## Values is the complete goat info, including the id

        ## Let's add them to the sync as needed
        ## Need to record each one as we add it in, so do this inline
        for my $goat (sort keys %{ $goatlist->{relations} }, sort keys %{ $livelist->{relations} }) {
            ## Okay, is this table part of the sync yet?
            ## Which really means, is it part of the source herd yet?
            my $herd = $sync->{herd}{name};
            print "Is table $goat part of the $herd herd?\n";
            my $result = add_goat_to_herd($herd, $goat);
            print "Result: $result\n";
        }


## gregstop
exit;

        ## Grab all goats in the source herd for this sync
        my $sourceherd = $info->{source};
        $SQL = 'SELECT id, schemaname, tablename FROM bucardo.goat g'
            . ' JOIN bucardo.herdmap h ON (h.goat = g.id) AND h.herd = ?';
        $sth = $dbh->prepare($SQL);
        $sth->execute($sourceherd);
        my $herdlist = $sth->fetchall_hashref('id');

        for my $tab (@nouns) {
            ## All of these must be valid tables
            my $t = $tab;
            my $wild = ($t =~ s/\*//) ? 1 : 0;
            my $find;
            if ($t =~ s/(\w+)\.//) {
                my $schema = $1;
                $SQL = 'SELECT * FROM bucardo.goat WHERE tablename = ? AND schemaname = ? AND reltype = ?';
                $wild and $SQL =~ s/=/~/;
                $find = $dbh->prepare_cached($SQL);
                $count = $find->execute($wild ? "^$t" : $t, $schema, $thing);
            }
            else {
                $SQL = 'SELECT * FROM bucardo.goat WHERE tablename = ? AND reltype = ?';
                $wild and $SQL =~ s/=/~/;
                $find = $dbh->prepare($SQL);
                $count = $find->execute($wild ? "^$t" : $t, $thing);
            }
            if ($count < 1) {
                die qq{Unknown table: $tab\n};
            }
            elsif ($count > 1 and ! $wild) {
                die qq{More than one table found for $tab: use wildcards or a schema\n};
            }

            my $tabinfo = $find->fetchall_arrayref({});
            for my $tab2 (@$tabinfo) {
                my $tabid = $tab2->{id};
                my $tablename = "$tab2->{schemaname}.$tab2->{tablename}";
                my $type = $tab2->{reltype};
                if ($v eq 'add' and exists $herdlist->{$tabid}) {
                    warn "Skipping $type $tablename: already part of that sync\n";
                    next;
                }
                if ($v eq 'remove' and !exists $herdlist->{$tabid}) {
                    warn "Skipping $type $tablename: does not belong to the sync\n";
                    next;
                }
                if ($v eq 'add') {
                    $SQL = 'INSERT INTO bucardo.herdmap(herd,goat) VALUES (?,?)';
                    my $add = $dbh->prepare($SQL);
                    $add->execute($sourceherd,$tabid);
                    my $lctype = lc $type;
                    warn "Added $lctype $tablename to herd $sourceherd\n";
                    if ($type eq 'table') {
                        $validate_msg = 1;
                    }
                }
                else {
                    $SQL = 'DELETE FROM bucardo.herdmap WHERE herd = ? AND goat = ?';
                    my $delete = $dbh->prepare($SQL);
                    $delete->execute($sourceherd,$tabid);
                    warn "Removed $type $tablename from herd $sourceherd\n";
                }
            }
        }

        if ($validate_msg) {
            print qq{Don't forget to run bucardo validate $name\n};
        }

        $dbh->commit();
        exit 0;
    }

    if ('dbgroup' eq $item and ($nouns[0] eq 'add' or $nouns[0] eq 'remove')) {
        my $v = shift @nouns;
        die "Can only $v to one dbgroup at a time\n" if @$info > 1;
        $info = $info->[0];
        my $miniusage = "Usage: update dbgroup $name $v <dbname(s)>\n";
        @nouns or die $miniusage;

        ## Grab all databases in this group
        $SQL = 'SELECT db, priority FROM bucardo.dbmap WHERE dbgroup = ?';
        $sth = $dbh->prepare($SQL);
        $sth->execute($name);
        my $dblist = $sth->fetchall_hashref('db');

        for my $db (@nouns) {
            ## All of these must be valid databases
            my $d = $db;
            my $wild = ($d =~ s/\*//) ? 1 : 0;
            my $find;
            $SQL = 'SELECT * FROM bucardo.db WHERE name = ?';
            $wild and $SQL =~ s/=/~/;
            $find = $dbh->prepare($SQL);
            $count = $find->execute($wild ? "^$d" : $d);
            if ($count < 1) {
                die qq{Unknown database: $db\n};
            }
            elsif ($count > 1 and ! $wild) {
                die qq{More than one database found for $db\n};
            }

            if ($v eq 'add' and exists $dblist->{$d}) {
                warn "Skipping dbgroup $db: already part of that group\n";
                next;
            }
            if ($v eq 'remove' and !exists $dblist->{$d}) {
                warn "Skipping dbgroup $db: does not belong to that group\n";
                next;
            }
            my $dbinfo = $find->fetchall_arrayref({});
            for my $db2 (@$dbinfo) {
                my $dbname = $db2->{name};
                if ($v eq 'add') {
                    $SQL = 'INSERT INTO bucardo.dbmap(db,dbgroup) VALUES (?,?)';
                    my $add = $dbh->prepare($SQL);
                    $add->execute($dbname,$name);
                    warn qq{Added database "$dbname" to database group "$name"\n};
                }
                else {
                    $SQL = 'DELETE FROM bucardo.dbmap WHERE db = ? AND dbgroup = ?';
                    my $delete = $dbh->prepare($SQL);
                    $delete->execute($dbname,$name);
                    warn qq{Removed database "$dbname" from database group "$name"\n};
                }
            }
        }

        $dbh->commit();
        exit 0;
    }

    if ('herd' eq $item and ($nouns[0] eq 'add' or $nouns[0] eq 'remove')) {
        my $v = shift @nouns;
        die "Can only $v to one herd at a time\n" if @$info > 1;
        $info = $info->[0];
        my $miniusage = "Usage: update herd $name $v <table(s)>\n";
        @nouns or die $miniusage;

        ## Grab all tables in this herd
        $SQL = 'SELECT g.id, g.schemaname, g.tablename FROM bucardo.goat g '
            . 'JOIN bucardo.herdmap h ON (h.goat = g.id) WHERE h.herd = ?';
        $sth = $dbh->prepare($SQL);
        $sth->execute($name);
        my $tablist = $sth->fetchall_hashref('id');

        my %found;

        if ($v eq 'remove') {

            for my $tab (@nouns) {
                my $wild = ($tab =~ s/\*//) ? 1 : 0;
                for my $id (keys %$tablist) {
                    my ($sname,$tname) = ($tablist->{$id}{schemaname}, $tablist->{$id}{tablename});
                    if ($wild) {
                        if ($tname =~ /$tab/) {
                            $found{$id} = [$sname,$tname];
                        }
                    }
                    elsif ($tab =~ /(.+)\.(.+)/) {
                        my ($s,$t) = ($1,$2);
                        if ($s eq $sname and $t eq $tname) {
                            $found{$id} = [$sname,$tname];
                        }
                    }
                    elsif ($tname eq $tab) {
                        $found{$id} = [$sname,$tname];
                    }
                }
            }

            if (keys %found) {
                $SQL = 'DELETE FROM bucardo.herdmap WHERE herd = ? AND goat = ?';
                $sth = $dbh->prepare($SQL);
                for my $id (sort keys %found) {
                    my ($sname,$tname) = @{$found{$id}};
                    $count = $sth->execute($name,$id);
                    if ($count >= 1) {
                        print "  Removed from herd $name: $sname.$tname\n";
                    }
                    else {
                        print "Could not remove from herd $name: $sname.$tname\n";
                    }
                }
                $dbh->commit();
            }

            exit 0;

        } ## end 'remove'

        ## Must be 'add'
        my $flatsql = 'SELECT id,schemaname,tablename FROM bucardo.goat WHERE tablename = ?';
        my $wildsql = 'SELECT id,schemaname,tablename FROM bucardo.goat WHERE tablename ~ ?';

        for my $tab (@nouns) {
            my $wild = ($tab =~ s/\*//) ? 1 : 0;

            $sth = $dbh->prepare($wild ? $wildsql : $flatsql);
            $count = $sth->execute($tab);
            next if $count < 1;

            for my $row (@{$sth->fetchall_arrayref()}) {
                $found{$row->[0]} = [$row->[1],$row->[2]];
            }
        }

        if (keys %found) {

            $SQL = 'INSERT INTO bucardo.herdmap(herd,goat) VALUES (?,?)';
            $sth = $dbh->prepare($SQL);
            for my $id (sort keys %found) {
                next if exists $tablist->{$id};
                $tablist->{$id}++;
                my ($sname,$tname) = @{$found{$id}};
                $count = $sth->execute($name,$id);
                if ($count >= 1) {
                    print "  Added to herd $name: $sname.$tname\n";
                }
                else {
                    print "Could not add to herd $name: $sname.$tname\n";
                }
            }
            $dbh->commit();
        }

        exit 0;
    }

    ## Process each change in turn
    ## Can be code, sync, dbgroup, table, schema, herd, or db
    my %change;
    for my $arg (@nouns) {
        next if $arg eq 'set';
        $arg =~ /(.+)=(.+)/ or die "Invalid argument: must be of form name=value\n";
        my ($n,$v) = (lc $1,$2);
        $n =~ /^\w+$/ or die "Invalid name\n";
        $n = 'server_side_prepares' if $n eq 'ssp';

        ## Special herd handling
        if ('herd' eq $item and 'notable' eq $n) {
            $SQL = 'DELETE FROM bucardo.herdmap WHERE herd = ? AND goat IN '
                . '(SELECT id FROM bucardo.goat WHERE tablename ~ ?)';
            $sth = $dbh->prepare($SQL);
            $count = $sth->execute($name, $v);
            if ($count >= 1) {
                push @{$change{$name}} => ['DIRECT', "Tables removed from herd: $count"];
            }
            next;
        }

        ## Special table handling
        if ('all' eq $name and 'table' eq $single_item) {
            ## Can only change a few things globally
            if ('standard_conflict' ne $n
                 and 'analyze_after_copy' ne $n
                     and 'vacuum_after_copy' ne $n) {
                die qq{Sorry, cannot change that for all tables\n};
            }
            $SQL = "UPDATE bucardo.goat SET $n = ? WHERE reltype='table'";
            $sth = $dbh->prepare($SQL);
            $sth->execute($v);
            push @{$change{'all tables'}} => [$n, 'N/A', $v];
            next;
        }

        ## Special table handling
        if ('all' eq $name and 'sequence' eq $single_item) {
            ## Can only change a few things globally
            if ('standard_conflict' ne $n) {
                die qq{Sorry, cannot change that for all sequences\n};
            }
            $SQL = "UPDATE bucardo.goat SET $n = ? WHERE reltype='sequence'";
            $sth = $dbh->prepare($SQL);
            $sth->execute($v);
            push @{$change{'all sequences'}} => [$n, 'N/A', $v];
            next;
        }

        for my $row (@$info) {
            my $localname = $tabname eq 'goat' ? "$row->{schemaname}.$row->{tablename}" : $row->{name};
            my $localid = $tabname eq 'goat' ? $row->{id} : $row->{name};
            if (! exists $row->{$n}) {
                die qq{Sorry, cannot change "$n" for $single_item "$localname"\n};
            }
            if ($tabname eq 'db' and $n eq 'dbhost' and $v eq 'none') {
                $SQL = "UPDATE bucardo.db SET dbhost = '' WHERE $pkcol = ?";
                $sth = $dbh->prepare($SQL);
                $sth->execute($localid);
                push @{$change{$localname}} => [$n, $row->{$n}, 'NULL'];
                next;
            }
            if ($tabname eq 'customcode' and $n eq 'src_code') {
                my $tfile = $v;
                if (! -e $tfile) {
                    die qq{The 'src_file' value must be a file\n};
                }
                open my $fh, '<', $tfile or die qq{Could not open "$tfile": $!\n};
                { local $/; $v = <$fh>; } ## no critic (RequireInitializationForLocalVars)
                close $fh or warn qq{Could not close "$tfile": $!\n};
            }

            $SQL = "UPDATE bucardo.$tabname SET $n = ? WHERE $pkcol = ?";
            ## Only one of targetdb and targetgroup can be set, no NULL the other one
            if ($n eq 'targetgroup') {
                $SQL =~ s/SET/SET targetdb=NULL,/;
            }
            elsif ($n eq 'targetdb') {
                $SQL =~ s/SET/SET targetgroup=NULL,/;
            }

            $sth = $dbh->prepare($SQL);
            if ($DEBUG) {
                warn "SQL: $SQL\n";
                warn "Args: $v, $localid\n";
            }
            $sth->execute($v, $localid);
            push @{$change{$localname}} => [$n, $row->{$n}, $v];
        }
    }

    if (! keys %change) {
        print "No changes made\n";
        exit 0;
    }

    my %maxcol;
    for my $thing (keys %change) {
        $maxcol{$thing} = 1;
        for my $row (@{$change{$thing}}) {
            $maxcol{$thing} = length($row->[0]) if length($row->[0]) > $maxcol{$thing};
        }
    }

    for my $thing (sort keys %change) {
        print qq{Changes made to $single_item "$thing":\n};
        for my $row (@{$change{$thing}}) {
            my $col = $row->[0];
            if ($col eq 'DIRECT') {
                print "$row->[1]\n";
                next;
            }
            my $old = defined $row->[1] ? qq{"$row->[1]"} : '(null)';
            my $new = qq{"$row->[2]"};
            if ($tabname eq 'customcode' and $col eq 'src_code') {
                my $lines = $old =~ tr/\n/\n/;
                $old = "old source (lines: $lines)";
                $lines = $new =~ tr/\n/\n/;
                $new = "contents of file 'foo' (lines: $lines)";
            }
            printf qq{ * %-*s : changed from %s to %s\n},
                $maxcol{$thing}, $col, $old, $new;
        }
    }

    $dbh->commit();
    $dbh->disconnect();

    exit 0;

} ## end of update


sub update_sync {

    ## Update a sync
    ## Arguments: two plus
    ## 1. Name of the sync to update. Can be "all" and can have wildcards
    ## 2. What exactly we are updating.
    ## Returns: undef

    my $name = shift or die;
    my @actions = @_;

    ## Recursively call ourselves for wildcards and 'all'
    return if ! check_recurse($SYNC, $name, @actions);

    ## Make sure this sync exists!
    if (! exists $SYNC->{$name}) {
        die qq{Could not find a sync named "$name"\nUse 'list syncs' to see all available.};
    }

    ## Adding something to this sync
    if ('add' eq $verb or 'insert' eq $verb) {

        ## Grab the first word after the verb
        my $noun = lc shift @actions || '';

        ## No noun? Bail out
        if (! length $noun) {
            die qq{Have not indicated what to $verb\n};
        }

        ## Basic choices: table and database
        if ($noun eq 'table' or $noun eq 'goat' or $noun eq 'sequence') {
            my $count = add_tables_to_sync($name, @actions);
        }
        elsif ($noun eq 'db' or $noun eq 'database') {
            add_dbs_to_sync($name, @actions);
        }
        else {
            ## Maybe they want to leave out the specifier.
            ## We'll try to guess by looking at the first item

            ## Perhaps it is a table or sequence?
            if (exists $GOAT->{$noun}) {
                add_tables_to_sync($name, $noun, @actions);
            }
            ## How about a database?
            elsif (exists $DB->{$noun}) {
                add_dbs_to_sync($name, $noun, @actions);
            }
            ## Maybe a table we do not know about yet?
            elsif (add_table_as_goat($noun)) {
                add_tables_to_sync($name, $noun, @actions);
            }
            else {
                die qq{Invalid update command\n};
            }
        }
        return;

    } ## end of 'add'

    ## Removing something from this sync
    if ('remove' eq $verb or 'delete' eq $verb or 'drop' eq $verb) {
        return;
    }

    ## Changing something about this sync
    if ('update' eq $verb or 'change' eq $verb) {
        for my $n (@nouns) {
            if ($n =~ /status=(.+)/) {
                my $onoff = $1;
                my $status = $onoff =~ /^active|on/ ? 'active' : 'inactive';
                $SQL = 'UPDATE sync SET status = ? WHERE name = ?';
                $sth = $dbh->prepare($SQL);
                $sth->execute($status, $name);
                $dbh->commit();
            }
        }
        return;
    }

    die qq{Unknown action "$verb": must be add, remove, or update\n};

    my $sync = $global{sync}{$name};

    ## Grab all tables used in this sync
    my @tables = keys %{ $sync->{herd}{goat} };
    
    if ($verb eq 'remove') {
        ## The list of tables to remove, fully qualified
        my %remove;
        
        ## Figure out which tables they really mean and verify they are part of the sync
        my $matches = get_arg_items(\@tables, \@nouns);
        
        if (! ref $matches) {
            die qq{Did not find any matching tables for "$matches" for sync "$name"\n};
        }

        ## Did we get any matches? Just in case...
        if (! keys %$matches) {
            die qq{No matching tables found to remove\n};
        }

        ## Remove each table from the herd
        my $herdname = $sync->{herd}{name};
        $SQL = 'DELETE FROM bucardo.herdmap WHERE herd = ? AND goat = ?';
        my $sth = $dbh->prepare($SQL);
        for my $fullname (sort keys %$matches) {
            my $goat = $global{goat}{$fullname}
                or die qq{Could not find an id for table "$fullname"!\n};
            $sth->execute($herdname,$goat->{id});
            print qq{Removed from sync "$name": $goat->{reltype} "$fullname"\n};
        }
        $dbh->commit();

        ## Report if any other syncs are using these tables
        my $synclist = $global{herd}{$herdname}{sync};
        my @othersyncs = grep { $_ ne $name } keys %$synclist;
        if (@othersyncs) {
            print qq{Warning! The following syncs were also using items from the herd "$herdname":\n};
            for my $s (sort @othersyncs) {
                print qq{  Sync "$s"\n};
            }
        }

        exit 0;

    } ## end of removing tables

    ## 'add'
    ## Must be valid known tables
    ## Auto-add ones that are not already there?
    ## Do we care if some do not match?
    ## At any rate, build a list, then add in ones that are not already part of the sync

    ## Build a list of tables we are adding.
    ## Give output about each as we process it
    ## Do not report on the same one twice.
    ## Report all success, then all failures
    
    ## Rethink: do this in two stages
    ## First, find any matches for tables we already know about, in $global{goat}
    ## Then, if needed, check the live database (add them as well)
    ## At the end of the day we have a list of ids
    ## Add those that are not already there
    ## Complain if they don't fit (e.g. need PKs)
    ## gregstop implement above

    ## First, find any matches for tables we already know about, in $global{goat}
    my $goatlist = get_goat_ids(@nouns);
    my $nouncount = @nouns;

    ## Figure out if we need to hit the live database to add potential tables
    ## We do not only if all nouns are of the format "a.b" and got a match
    my $goatnumber = keys %{ $goatlist->{relations} };

    ## Are there any not in the given format?
    my $searchlivetables = grep { ! /^\w+\.\w+$/ } @nouns;


    if (! $searchlivetables) {
        ## All are in the x.y format, but did we match them all?
        if ($nouncount != $goatnumber) {
            $searchlivetables = 1;
        }
    }
    
    my $livenumber = 0;
    my $livelist;
    if ($searchlivetables) {
        print "Searching live tables for matches to the nouns\n";
        ## Which database should we look in?
        my $sourcedb = $sync->{herd}{db};
        $livelist = get_live_goat_ids($sourcedb, @nouns);
        $livenumber = keys %{ $livelist->{relations} };
    }

    print "Found goat matches: $goatnumber\n";
    print "Found live matches: $livenumber\n";
    print "Nouns to scan: $nouncount\n";

    ## We now have two lists both containing hash with keys as the schema.table names
    ## Values is the complete goat info, including the id

    ## Let's add them to the sync as needed
    ## Need to record each one as we add it in, so do this inline
    for my $goat (sort keys %{ $goatlist->{relations} }, sort keys %{ $livelist->{relations} }) {
        ## Okay, is this table part of the sync yet?
        ## Which really means, is it part of the source herd yet?
        my $herd = $sync->{herd}{name};
        print "Is table $goat part of the $herd herd?\n";
        my $result = add_goat_to_herd($herd, $goat);
        print "Result: $result\n";
    }


    ## gregstop
    exit;
} ## end of update_sync







sub add_tables_to_sync {

    ## Adds one or more tables or sequences to a sync
    ## Which means it really adds them to the "source" herd
    ## Arguments: two plus
    ## 1. The name of the sync
    ## 2. The items to add. May have wildcards
    ## Returns: ? number added? List?

    my $syncname = shift or die;
    my $sync = $SYNC->{$syncname} or die qq{Unknown sync: $syncname};

    my @names = @_;

    ## How many items we got?
    my $nouncount = @names;

    ## First, see if we can find matches for known goats
    my $goatlist = get_goat_ids(@names);

    ## Figure out if we need to hit the live database to add potential tables
    ## We do not only if 1) all nouns are of the format "a.b" and 2) got a match
    my $goatnumber = keys %{ $goatlist->{relations} };

    ## Are there any not in the given format?
    my $searchlivetables = grep { ! /^\w+\.\w+$/ } @nouns;

    if (! $searchlivetables) {
        ## All are in the x.y format, but did we match them all?
        if ($nouncount != $goatnumber) {
            $searchlivetables = 1;
        }
    }

    ## Store how many "live" relations we add
    my $livenumber = 0;
    ## The list of "live" relations
    my $livelist;

    if ($searchlivetables) {
        print "Searching live tables for matches to the nouns\n";
        ## Which database should we look in?
        my $sourcedb = $sync->{herd}{db};
        $livelist = get_live_goat_ids($sourcedb, @nouns);
        $livenumber = keys %{ $livelist->{relations} };
    }

    print "Found goat matches: $goatnumber\n";
    print "Found live matches: $livenumber\n";
    print "Nouns to scan: $nouncount\n";

    ## We now have two lists both containing hash with keys as the schema.table names
    ## Values is the complete goat info, including the id

    ## Let's add them to the sync as needed
    ## Need to record each one as we add it in, so do this inline
    for my $goat (sort keys %{ $goatlist->{relations} }, sort keys %{ $livelist->{relations} }) {
        ## Okay, is this table part of the sync yet?
        ## Which really means, is it part of the source herd yet?
        my $herd = $sync->{herd}{name};
        print "Is table $goat part of the $herd herd?\n";
        my $result = add_goat_to_herd($herd, $goat);
        print "Result: $result\n";
    }




    die "Complete me";

    return;

} ## end of add_tables_to_sync


sub add_table_as_goat {

    ## Adds a named table (or tables) to the goat table, returning the new goat.id
    ## Arguments: 1
    ## 1. Name of the table or schema
    ## Returns: newly created goat.id, 0 if anything failed

    my $name = shift;

    ## We do not allow wildcards, but we do allow a single table to match multiple schemas
    my $schema = '';
    my $table = $name;
    if ($name =~ /^(\w+)\.(\w+)/) {
        ($schema,$table) = ($1,$2);
    }

    ## Return a list of "schema.relnames" which match
my @tables;
die;
#    my @tables = find_tables($whichdb, $schema, $table);

    ## The final list of ids to return
    my @ids;

    my $newtables = 0;
    for my $name (@tables) {
        ## Skip if we already know about it
        ## Return the id anyway?
        if (exists $GOAT->{$name}) {
            push @ids => $GOAT->{$name}{id};
            next;
        }
        $newtables++;
        $SQL = 'INSERT INTO bucardo.goat() VALUES ()';
    }

    ## Reload it

    my $id = 0;




    return $id;

} ## end of add_table_as_goat


sub add_goat_to_herd {

    ## Given a herd and one or more goats, add them to the herdmap as needed
    ## Arguments: two
    ## 1. The name of the herd
    ## 2. The name or id of the goat
    ## Returns: number of items added

    my $herd = shift or die;
    my $goat = shift or die;

    $SQL = 'SELECT 1 FROM bucardo.herdmap WHERE herd=? AND goat=?';
    my $sth = $dbh->prepare($SQL);

    ## Make sure the goat is in the form of an id and that it exists
    if ($goat =~ /^\d+$/o) {
        exists $global{goat}{id}
            or die qq{Could not find a goat with id $goat};
    }
    else {
        exists $global{goat}{$goat}
            or die qq{Could not find a goat with the name "$goat"};
        $goat = $global{goat}{$goat}{id};
    }

    exists $global{herd}{$herd}
        or die qq{Could not find a herd with the name "$herd"};

    $count = $sth->execute($herd,$goat);
    ## Already exists, so do nothing and report back zero
    if ($count >= 1) {
        $sth->finish();
        return 0;
    }

    $SQL = 'INSERT INTO bucardo.herdmap(herd,goat) VALUES (?,?)';
    $sth = $dbh->prepare($SQL);
    $sth->execute($herd,$goat);

    return 1;

} ## end of add_goat_to_herd


sub get_goat_ids {

    ## Returns the ids from the goat table for matching relations
    ## Also checks the live database and adds tables to the goat table as needed.
    ## Arguments: single hashref:
    ##  - args: arrayref of names to match against. Can have wildcards.
    ##  - dbcols: optionl hashref of fields to populate goat table with (e.g. ping=1)
    ## Returns a hash with:
    ##  - relations: hash of goat objects, key is the fully qualified name
    ##    - original: hash of search term(s) used to find this
    ##    - goat: the goat object
    ##  - nomatch: hash of non-matching terms
    ##  - match: hash of matching terms
    ##  - new: hash of newly added tables

    my $arg = shift || {};
    my $names = $arg->{args} or die;
    my $dbcols = $arg->{dbcols} || {};

    ## The final hash we return
    my %relation;

    ## Args that produced a match
    my %match;

    ## Args that produced no matches at all
    my %nomatch;

    ## Keep track of which args we've already done, just in case there are dupes
    my %seenit;

    ## Which tables we added to the goat table
    my %new;

    ## Figure out which database to search in
    my $bestdb = find_best_db_for_searching();

    ## This check still makes sense: if no databases, there should be nothing in $GOAT!
    if (! defined $bestdb) {
        die "No databases have been added yet, so we cannot add tables!\n";
    }

    my $rdbh = connect_database({name => $bestdb}) or die;

    ## SQL to find a table or a sequence
    ## We do not want pg_table_is_visible(c.oid) here
    my $BASESQL = q{
SELECT nspname||'.'||relname AS name, relkind, c.oid
FROM pg_class c
JOIN pg_namespace n ON (n.oid = c.relnamespace)
WHERE relkind IN ('r')
AND nspname <> 'information_schema'
AND nspname !~ '^pg_'
};

    ## Loop through each argument, and try and find matching goats
  ITEM: for my $item (@$names) {

        ## In case someone entered duplicate arguments
        next if $seenit{$item}++;

        ## Skip if this is not a tablename, but an arguement of the form x=y
        next if index($item, '=') >= 0;

        ## Determine if this item has a dot in it, and/or it is using wildcards
        my $hasadot = index($item,'.') >= 0 ? 1 : 0;
        my $hasstar = (index($item,'*') >= 0 or index($item,'%') >= 0) ? 1 : 0;

        ## Temporary list of matching items
        my @matches;

        ## A list of tables to be bulk added to the goat table
        my %addtable;

        ## We may mutate the arg, so stow away the original
        my $original_item = $item;

        ## On the first pass, we look for matches in the existing $GOAT hash
        ## We may also check the live database afterwards

        ## Wildcards?
        if ($hasstar) {

            ## Change to a regexier form
            $item =~ s/\./\\./g;
            $item =~ s/[*%]/\.\*/g;
            $item = "^$item" if $item !~ /^[\^\.\%]/;
            $item .= '$' if $item !~ /[\$\*]$/;

            ## Pull back all items from the GOAT hash that have a dot in them
            for my $fullname (grep { /\./ } keys %{ $GOAT }) {

                ## We match against the whole thing if we have a dot
                ## in our search term, otherwise we only match the table
                my $searchname = $fullname;
                if (! $hasadot) {
                    (undef,$searchname) = split /\./ => $fullname;
                }

                ## Id we got a match, store the item from the GOAT that caused it
                if ($searchname =~ /^$item$/) {
                    push @matches => $fullname;
                }
            }

            ## Setup the SQL to search the live database
            $SQL = $BASESQL . ($hasadot
                ? "AND nspname||'.'||relname ~ ?"
                : "AND relname ~ ?");

        } ## end wildcards

        ## A dot with no wildcards: exact match
        ## TODO: Allow foobar. to mean foobar.% ??
        elsif ($hasadot) {

            if (exists $GOAT->{$item}) {
                push @matches => $item;
            }

            ## No need to check live if we found a match
            next ITEM if @matches;

            ## Setup the SQL to search the live database
            $SQL = $BASESQL . q{AND nspname||'.'||relname = ?};
        }

        ## No wildcards and no dot, so we match all tables regardless of the schema
        else {

            ## Pull back all items from the GOAT hash that have a dot in them
            for my $fullname (grep { /\./ } keys %{ $GOAT }) {
                my ($schema,$table) = split /\./ => $fullname;
                if ($table eq $item) {
                    push @matches => $fullname;
                }
            }

            ## Setup the SQL to search the live database
            $SQL = $BASESQL . 'AND relname = ?';
        }

        ## Search the live database for matches
        $sth = $rdbh->prepare($SQL);
        ($count = $sth->execute($item)) =~ s/0E0/0/;
        debug(qq{Searched live database "$bestdb" for arg "$item", count was $count});
        for my $row (@{ $sth->fetchall_arrayref({}) }) {

            ## The 'name' is combined "schema.relname"
            my $name = $row->{name};

            ## Don't bother if we have already added this!
            next if exists $GOAT->{$name};

            ## Document the string that led us to this one
            $relation{$name}{original}{$item}++;

            ## Document the fact that we found this on a database
            $new{$name}++;

            ## Mark this item as having produced a match
            $match{$item}++;

            ## Set this table to be added to the goat table below
            $addtable{$name} = {db => $bestdb, reltype => $row->{relkind}, dbcols => $dbcols};

            ## Add this to our matching list
            push @matches => $name;

        }

        ## Add all the tables we just found from searching the live database
        if (keys %addtable) {
            add_items_to_goat_table(\%addtable);
        }

        ## Populate the final hashes based on the match list
        for my $name (@matches) {
            $relation{$name}{original}{$original_item}++;
            $relation{$name}{goat} ||= $GOAT->{$name};
            $match{$item}++;
        }

        ## If this item did not match anything, note that as well
        if (! @matches) {
            $nomatch{$original_item}++;
        }

    } ## end each given needle

    return {
        relations  => \%relation,
        nomatch    => \%nomatch,
        match      => \%match,
        new        => \%new,
    };

} ## end of get_goat_ids


sub add_items_to_goat_table {

    ## Given a list of tables, add them to the goat table as needed
    ## Arguments: 1
    ## 1. Hashref where keys are the relnames, and values are additional info:
    ##   - db: the database name (mandatory)
    ##   - reltype: table or sequence (optional, defaults to table)
    ##   - dbcols: optional hashref of goat columns to set
    ## Returns: arrayref with all the new goat.ids

    my $info = shift or die;

    ## Quick check if the entry is already there.
    $SQL = 'SELECT id FROM bucardo.goat WHERE schemaname=? AND tablename=? AND db=?';
    my $isthere = $dbh->prepare($SQL);

    ## SQL to add this new entry in
    my $NEWGOATSQL = "INSERT INTO bucardo.goat (schemaname,tablename,reltype,db) VALUES (?,?,?,?) RETURNING id";

    my @newid;

    for my $name (sort keys %$info) {
        if ($name !~ /^(\w+)\.(\w+)$/o) {
            die qq{Invalid name, got "$name", but expected format "schema.relname"};
        }
        my ($schema,$table) = ($1,$2);

        my $db = $info->{$name}{db} or die qq{Must provide a database};

        my $reltype = $info->{$name}{reltype} || 't';
        $reltype = $reltype =~ /s/i ? 'sequence' : 'table';

        ## Adjust the SQL as necessary for this goat
        $SQL = $NEWGOATSQL;
        my @args = ($schema, $table, $reltype, $db);
        if (exists $info->{$name}{dbcols}) {
            for my $newcol (sort keys %{ $info->{$name}{dbcols} }) {
                $SQL =~ s/\)/,$newcol)/;
                $SQL =~ s/\?,/?,?,/;
                push @args => $info->{$name}{dbcols}{$newcol};
            }
        }
        $sth = $dbh->prepare($SQL);
        ($count = $sth->execute(@args)) =~ s/0E0/0/;

        debug(qq{Added "$schema.$table" to goat table with db "$db", count was $count});

        push @newid => $sth->fetchall_arrayref()->[0][0];
    }

    ## Update the global
    load_bucardo_info('force_reload');

    ## Return a list of goat objects
    my %newlist;
    for my $id (@newid) {
        my $goat = $global{goat}{$id};
        my $name = "$goat->{schemaname}.$goat->{tablename}";
        $newlist{$name} = $goat;
    }

    return \%newlist;


} ## end of add_items_to_goat_table


sub get_arg_items {

    ## From an argument list, return all matching items
    ## Arguments: 2
    ## 1. Arrayref of source items to match on
    ## 2. Arrayref of arguments
    ## Returns an arrayref of matches, or an single scalar indicating what arg failed

    my ($haystack, $needles) = @_;

    my %match;

    for my $needle (@$needles) {

        my $hasadot = index($needle,'.') >= 0 ? 1 : 0;
        my $hasstar = (index($needle,'*') >= 0 or index($needle,'%') >= 0) ? 1 : 0;

        ## Wildcards?
        if ($hasstar) {

            ## Change to a regexier form
            $needle =~ s/\*/\.\*/g;

            ## Count matches: if none found, we bail
            my $found = 0;
            for my $fullname (@$haystack) {
                ## If it has a dot, match the whole thing
                if ($hasadot) {
                    if ($fullname =~ /^$needle$/) {
                        $match{$fullname} = $found++;
                    }
                    next;
                }

                ## No dot, so match table part only
                my ($schema,$table) = split /\./ => $fullname;
                if ($table =~ /^$needle$/) {
                    $match{$fullname} = $found++;
                }
            }

            return $needle if ! $found;

            next;

        } ## end wildcards

        ## If it has a dot, it must match exactly
        if ($hasadot) {
            if (grep { $_ eq $needle } @$haystack) {
                $match{$needle} = 1;
                next;
            }
            return $needle;
        }

        ## No dot, so we match all tables regardless of the schema
        my $found = 0;
        for my $fullname (@$haystack) {
            my ($schema,$table) = split /\./ => $fullname;
            if ($table eq $needle) {
                $match{$fullname} = $found++;
            }
        }
        return $needle if ! $found;

    } ## end each given needle


    return \%match; ## May be undefined

} ## end of get_arg_items


sub ping {

    ## See if the MCP is alive and responds to pings
    ## Default is to wait 15 seconds

    my $arg = shift || {};

    my $timeout = $arg->{timeout} || $ARGV[0] || 15;
    my $quiet = $arg->{quiet} || $ARGV[1] || 0;

    if (defined $nouns[0] and $nouns[0] =~ /^\d+$/) {
        $timeout = $nouns[0];
    }

    $VERBOSE and print "Pinging MCP, timeout = $timeout\n";
    $dbh->do('LISTEN bucardo_mcp_pong');
    $dbh->do('NOTIFY bucardo_mcp_ping');
    $dbh->commit();
    my $starttime = time;
    sleep 0.1;

  P:{
        my $notify = $dbh->func('pg_notifies');
        if (defined $notify) {
            my ($name, $pid, $payload) = @$notify;
            $quiet or print "OK: Got response from PID $pid\n";
            return $pid if $arg->{noexit};
            exit 0;
        }
        $dbh->rollback();
        sleep 0.5;
        my $totaltime = time - $starttime;
        if ($timeout and $totaltime >= $timeout) {
            $quiet or print "CRITICAL: Timed out ($totaltime s), no ping response from MCP\n";
            return 0 if $arg->{noexit};
            exit 1;
        }
        redo;
    }

    return;

} ## end of ping


sub kick {

    my $usage = usage('kick');

    if (!@nouns) {
        warn "$usage\n";
        exit 1;
    }

    my ($exitstatus, $retries, $do_retry) = (0,0,0);

  RETRY: {
        $dbh->rollback();
        $exitstatus = 0;
      SYNC: for my $sync (@syncs) {
            my $relname = "bucardo_kick_sync_$sync";

            ## If this sync is not active, cowardly refuse to kick it
            if ($syncs->{$sync}{status} ne 'active') {
                print qq{Cannot kick inactive sync "$sync"\n};
                next SYNC;
            }

            $dbh->do(qq{NOTIFY "bucardo_kick_sync_$sync"});
            my $done = "bucardo_syncdone_$sync";
            my $killed = "bucardo_synckill_$sync";
            if (! defined $adverb) {
                $dbh->commit();
                $QUIET or print qq{Kicked sync $sync\n};
                next;
            }

            $QUIET or print qq{Kick $sync: };
            $dbh->do(qq{LISTEN "$done"});
            $dbh->do(qq{LISTEN "$killed"});
            my $s = $syncs->{$sync};
            $dbh->do(qq{LISTEN "bucardo_syncdone_$sync"});
            $dbh->commit();

            my $time = time;
            sleep 0.1;

            my $timeout = (defined $adverb and $adverb > 0) ? $adverb : 0;

            my $printstring = $NOTIMER ? '' : '[0 s] ';
            print $printstring unless $QUIET or $NOTIMER;
            my $oldtime = 0;
            local $SIG{ALRM} = sub { die 'Timed out' };
            $do_retry = 0;
            eval {
                if ($timeout) {
                    alarm $timeout;
                }
              WAITIN: {
                    my $lastwait = '';
                    if ($PROGRESS and time - $time != $oldtime) {
                        $oldtime = time - $time;
                        if (!$QUIET and !$NOTIMER) {
                            print "\b" x length($printstring);
                            $printstring =~ s/\d+/$oldtime/;
                            print $printstring;
                        }
                    }
                    for my $notice (@{ db_get_notices($dbh) }) {
                        my ($name) = @$notice;
                        if ($name eq $done) {
                            $lastwait = 'DONE!';
                        }
                        elsif ($name eq $killed) {
                            $lastwait = 'KILLED!';
                            $exitstatus = 2;
                        }
                        elsif ($name =~ /^bucardo_syncdone_${sync}_(.+)$/) {
                            my $new = sprintf '%s(%ds) ', $1, ceil(time-$time);
                            print $new unless $QUIET;
                            $printstring .= $new;
                        }
                        elsif ($name =~ /^bucardo_synckill_${sync}_(.+)$/) {
                            my $new = sprintf '%s KILLED (%ds) ', $1, ceil(time-$time);
                            print $new unless $QUIET;
                            $printstring .= $new;
                            $exitstatus = 2;
                            $lastwait = ' ';
                        }
                    }
                    $dbh->rollback();
                    if ($lastwait) {
                        print $lastwait unless $QUIET;
                        if ($lastwait ne 'DONE!' and $RETRY and ++$retries <= $RETRY) {
                            print "Retry #$retries\n";
                            $do_retry = 1;
                            die "Forcing eval to exit for retry attempt\n";
                        }
                        last WAITIN;
                    }
                    sleep($WAITSLEEP);
                    redo WAITIN;

                } ## end of WAITIN

                alarm 0 if $timeout;
            };

            alarm 0 if $timeout;
            if ($do_retry) {
                $do_retry = 0;
                redo RETRY;
            }

            if (2 == $exitstatus) {
                my $reason = show_why_sync_killed($sync);
                $reason and print "\n$reason\n";
            }

            if ($@) {
                if ($@ =~ /Timed out/o) {
                    $exitstatus = 1;
                    warn "Timed out!\n";
                }
                else {
                    $exitstatus = 3;
                    warn "Error: $@\n";
                }
                next SYNC;
            }
            next SYNC if $QUIET;

            if ($PROGRESS) {
                print "\n";
            }
            else {
                printf "(%ds)\n", ceil(time - $time);
            }
        } ## end each sync

    } ## end RETRY

    exit $exitstatus;

} ## end of kick


sub show_why_sync_killed {

    ## If a kick results in a "KILLED!" try and show why

    my $sync = shift;

    $SQL = q{
SELECT * FROM bucardo.q
WHERE sync = ?
AND aborted IS NOT NULL
AND LENGTH(whydie) > 2
AND aborted >= now() - '30 seconds'::interval
ORDER BY aborted DESC LIMIT 1
};
    $sth = $dbh->prepare($SQL);
    $count = $sth->execute($sync);
    if ($count != 1) {
        $sth->finish();
        return '';
    }

    my $result = $sth->fetchall_arrayref({})->[0];
    (my $whydie = $result->{whydie}) =~ s/\\n */\n    /g;
    $whydie =~ s/: ERROR:/:\n    ERROR:/;
    $whydie =~ s/ (at .+ line \d+\.)/\n      $1/g;
    $whydie =~ s/\t/<tab>/g;
    my $msg = sprintf "  PID: %s\n  Started: %s\n  Ended: %s\n    %s",
        $result->{pid}, $result->{started}, $result->{aborted}, $whydie;

    return $msg;

} ## end of show_why_sync_killed


sub status_all {

    ## Show status of all syncs in the database

    ## See if the MCP is running and what its PID is
    if (! -e $PIDFILE) {
        #print " (Bucardo does not appear to be currently running)\n";
    }
    else {
        my $fh;
        if (!open $fh, '<', $PIDFILE) {
            print "\nERROR: Could not open $PIDFILE: $!";
        }
        else {
            my $pid = <$fh>;
            chomp $pid;
            close $fh or warn qq{Could not close $PIDFILE: $!\n};
            if ($pid =~ /^\d+$/) {
                print "PID of Bucardo MCP: $pid";
            }
            else {
                print "\nERROR: $PIDFILE contained: $pid";
            }
        }
    }
    print "\n";

    my $orderby = $bcargs->{sort} || '1';
    if ($orderby !~ /^\+?\-?\d$/) {
        die "Invalid sort option, must be +- 1 through 9\n";
    }

    our ($synclist,$max);
    ($synclist,$max) = get_detailed_syncs();

    if (! keys %$synclist) {
        print "No syncs have been created yet.\n";
        exit 0;
    }

    ## The titles
    my %title = (
        name     => ' Name',
        state    => ' State',
        lastgood => ' Last good',
        timegood => ' Time',
        dit      => ($max->{truncate} ?
                    $max->{conflicts} ? ' Last I/D/T/C' : ' Last I/D/T' :
                    $max->{conflicts} ? ' Last I/D/C' :' Last I/D'),
        lastbad  => ' Last bad',
        timebad  => ' Time',
    );

    ## Set the maximum as needed based on the titles
    for my $name (keys %title) {
        if (! exists $max->{$name}
                or length($title{$name}) > $max->{$name}) {
            $max->{$name} = length $title{$name};
        }
    }

    ## Account for our extra spacing by bumping everything up
    for my $var (values %$max) {
        $var += 2;
    }

    printf qq{%-*s %-*s %-*s %-*s %-*s %-*s %-*s\n},
        $max->{name},     $title{name},
        $max->{state},    $title{state},
        $max->{lastgood}, $title{lastgood},
        $max->{timegood}, $title{timegood},
        $max->{dit},      $title{dit},
        $max->{lastbad},  $title{lastbad},
        $max->{timebad},  $title{timebad};

    printf qq{%s+%s+%s+%s+%s+%s+%s\n},
        '=' x $max->{name},
        '=' x $max->{state},
        '=' x $max->{lastgood},
        '=' x $max->{timegood},
        '=' x $max->{dit},
        '=' x $max->{lastbad},
        '=' x $max->{timebad};

    ## If fancy sorting desired, call the list ourself to sort
    sub sortme {
        my $sortcol = $bcargs->{sort} || 1;

        +1 == $sortcol and return $a cmp $b;
        -1 == $sortcol and return $b cmp $a;

        my ($uno,$dos) = ($synclist->{$a}, $synclist->{$b});

        ## State
        +3 == $sortcol and return ($uno->{state} cmp $dos->{state} or $a cmp $b);
        -3 == $sortcol and return ($dos->{state} cmp $uno->{state} or $a cmp $b);

        ## Last good
        +5 == $sortcol and return ($uno->{lastgoodsecs} <=> $dos->{lastgoodsecs} or $a cmp $b);
        -5 == $sortcol and return ($dos->{lastgoodsecs} <=> $uno->{lastgoodsecs} or $a cmp $b);

        ## Good time
        +6 == $sortcol and return ($uno->{lastgoodtime} <=> $dos->{lastgoodtime} or $a cmp $b);
        -6 == $sortcol and return ($dos->{lastgoodtime} <=> $uno->{lastgoodtime} or $a cmp $b);

        if ($sortcol == 7 or $sortcol == -7) {
            my ($total1,$total2) = (0,0);
            while ($uno->{dit} =~ /(\d+)/go) {
                $total1 += $1;
            }
            while ($dos->{dit} =~ /(\d+)/go) {
                $total2 += $1;
            }

            7 == $sortcol and return ($total1 <=> $total2 or $a cmp $b);

            return ($total2 <=> $total1 or $a cmp $b);
        }

        ## Last bad
        +8 == $sortcol and return ($uno->{lastbadsecs} <=> $dos->{lastbadsecs} or $a cmp $b);
        -8 == $sortcol and return ($dos->{lastbadsecs} <=> $uno->{lastbadsecs} or $a cmp $b);

        ## Bad time
        +9 == $sortcol and return ($uno->{lastbadtime} <=> $dos->{lastbadtime} or $a cmp $b);
        -9 == $sortcol and return ($dos->{lastbadtime} <=> $uno->{lastbadtime} or $a cmp $b);


        return $a cmp $b;

    }

    for my $sync (sort sortme keys %$synclist) {
        my $s = $synclist->{$sync};
        next if ! exists $s->{state}; ## e.g. has been filtered out by args

        ## Populate any missing fields with an empty string
        for my $name (keys %title) {
            if (! exists $s->{$name}) {
                $s->{$name} = '';
            }
        }

        my $X = '|';
        printf qq{%-*s$X%-*s$X%-*s$X%-*s$X%-*s$X%-*s$X%-*s\n},
            $max->{name}," $sync ",
            $max->{state}, " $s->{state} ",
            $max->{lastgood}, " $s->{lastgood} ",
            $max->{timegood}, " $s->{timegood} ",
            $max->{dit}, " $s->{dit} ",
            $max->{lastbad}, " $s->{lastbad} ",
            $max->{timebad}, " $s->{timebad} ";
    }

    exit 0;

} ## end of status_all


sub status_detail {

    ## Show detailed information about one or more syncs

    ## Verify that all named syncs exist
    my ($synclist,$max) = get_detailed_syncs({syncs => \@nouns});

    my @synclist;
    for my $sync (sort @nouns) {
        $DEBUG and warn "Verify sync: $sync\n";
        next if $sync eq 'sync';
        if (!exists $synclist->{$sync}) {
            ## If a number, skip for ease of "kick name #" toggling
            $sync !~ /^\d+$/ and die "No such sync: $sync\n";
        }
        else {
            push @synclist => $sync;
        }
    }

    ## Grab the mappings from herd to database
    ## We only need one from each herd!
    $SQL = 'SELECT name FROM bucardo.herd';
    $sth = $dbh->prepare($SQL);
    $sth->execute();
    my $herdmap = $sth->fetchall_hashref('name');
    for my $herdname (keys %$herdmap) {
        $SQL = 'SELECT db FROM bucardo.goat WHERE id = (SELECT goat FROM bucardo.herdmap WHERE herd = ? LIMIT 1)';
        $sth = $dbh->prepare($SQL);
        $sth->execute($herdname);
        my $goatinfo = $sth->fetchall_arrayref({})->[0];
        $herdmap->{$herdname}{database} = $goatinfo->{db};
    }

    ## Present each ordered by name
    for my $sync (sort { lc $a cmp lc $b } @synclist) {
        print '=' x 70; print "\n";
        my $s = $synclist->{$sync};

        my @items;

        ## The source database we get the tables from
        my $sourcedb = $herdmap->{$s->{herd}}{database} || '?';

        ## Determine how many tables are in this sync
        $SQL = 'SELECT count(*) FROM bucardo.herdmap WHERE herd = ?';
        $sth = $dbh->prepare($SQL);
        $sth->execute($s->{herd});
        my $numtables = $sth->fetch()->[0];

        ## Last good time, and number of rows affected
        if (exists $s->{rowgood}) {
            my $tt = pretty_time($s->{rowgood}{total_time});
            push @items => ['Last good', "$s->{rowgood}{started_time} (time to run: $tt)"];

            ## Space out the numbers
            $s->{dit} =~ s{/}{ / }g;
            ## Pretty comma formatting (based on ENV)
            $s->{dit} =~ s/(\d+)/pretty_number($1)/ge;

            ## Change the title if we have any truncates
            my $extra = $max->{truncates} ? '/truncates' : '';

            ## Change the title if we have any conflicts
            $extra .= $max->{conflicts} ? '/conflicts' : '';

            push @items => ["Rows deleted/inserted$extra", $s->{dit}];
        }

        ## Last bad time, and the exact error
        ## The error should always be last, so we defer adding it to the queue
        my $lasterror = '';
        if (exists $s->{rowbad}) {
            my $tt = pretty_time($s->{rowbad}{total_time});
            push @items => ['Last bad',  "$s->{rowbad}{started_time} (time until fail: $tt)"];

            ## Grab the error message, and strip out trailing whitespace
            ($lasterror = $s->{rowbad}{status}) =~ s/\s+$//;
            ## Add any newlines back in
            $lasterror =~ s/\\n/\n/g;
            ## Remove starting whitespace
            $lasterror =~ s/^\s+//;
        }

        ## Undefined should be written as 'none'
        for (qw/checktime/) {
            $s->{$_} ||= 'none';
        }

        ## Should be 'yes' or 'no'
        for (qw/analyze_after_copy vacuum_after_copy stayalive kidsalive ping do_listen usecustomselect/) {
            $s->{$_} = (defined $s->{$_} and $s->{$_}) ? 'yes' : 'no ';
        }

        ## If currently running, there should be a PID file
        if (exists $s->{PIDFILE}) {
            push @items => ['PID file'         => $s->{PIDFILE}];
            push @items => ['PID file created' => $s->{CREATED}];
        }

        ## Build the display list
        push @items => ['Sync name'            => $sync];
        push @items => ['Current state'        => $s->{state}];
        push @items => ['Source herd/database' => "$s->{herd} / $sourcedb"];
        push @items => ['Tables in sync'       => $numtables];
        push @items => ['Status'               => $s->{status}];
        push @items => ['Check time'           => $s->{checktime}];
        push @items => ['Overdue time'         => $s->{overdue}];
        push @items => ['Expired time'         => $s->{expired}];
        push @items => ['Stayalive/Kidsalive'  => "$s->{stayalive} / $s->{kidsalive}"];
        push @items => ['Rebuild index'        => $s->{rebuild_index}];
        push @items => ['Ping'                 => $s->{ping}];
        push @items => ['Onetimecopy'          => $s->{onetimecopy}];

        ## Only show these if enabled
        if ($s->{usecustomselect} eq 'yes') {
            push @items => ['Custom select', $s->{usecustomselect}];
        }
        if ($s->{analyze_after_copy} eq 'yes') {
            push @items => ['Post-copy analyze', 'Yes'];
        }
        if ($s->{vacuum_after_copy} eq 'yes') {
            push @items => ['Post-copy vacuum', 'Yes'];
        }

        ## Final items:
        push @items => ['Last error:' => $lasterror];

        ## Figure out the maximum size of the left-hand items
        my $leftmax = 0;
        for (@items) {
            $leftmax = length $_->[0] if length $_->[0] > $leftmax;
        }

        ## Print it all out
        for (@items) {
            printf "%-*s : %s\n",
                $leftmax, $_->[0], $_->[1];
        }

    }
    exit 0;

} ## end of status_detail


sub get_config {

    my $name = shift;

    $SQL = 'SELECT value FROM bucardo.bucardo_config WHERE lower(setting) = ?';
    $sth = $dbh->prepare_cached($SQL);
    $count = $sth->execute(lc $name);
    if ($count < 1) {
        $sth->finish();
        die "Invalid bucardo_config setting: $name\n";
    }
    return $sth->fetchall_arrayref()->[0][0];

} ## end of get_config


sub append_reason_file {

    my $event = shift or die;

    my $string = sprintf "%s | %-5s | %s\n", (scalar localtime), $event, $nouns;

    open my $fh, '>', $REASONFILE or die qq{Could not open "$REASONFILE": $!\n};
    print {$fh} $string;
    close $fh or warn qq{Could not close $REASONFILE: $!\n};
    open $fh, '>>', $REASONFILE_LOG or die qq{Could not open "$REASONFILE_LOG": $!\n};
    print {$fh} $string;
    close $fh or warn qq{Could not close $REASONFILE_LOG: $!\n};
    return 1;

} ## end of append_reason_file


sub stop_bucardo {

    open my $stop, '>', $STOPFILE or die qq{Could not create "$STOPFILE": $!\n};
    print {$stop} "Stopped by $progname on " . (scalar localtime) . "\n";
    close $stop or warn qq{Could not close "$STOPFILE": $!\n};
    return;

} ## end of stop_bucardo


sub get_detailed_syncs {

    my $arg = shift || {};

    my $synclist = get_syncs();

    ## View the details of the syncs via the syncrun table

    $SQL = qq{
SELECT *,
TO_CHAR(started,'$DATEFORMAT') AS started_time,
CASE WHEN current_date = ended::date
  THEN TO_CHAR(ended,'$SHORTDATEFORMAT')
  ELSE TO_CHAR(ended,'$DATEFORMAT') END AS ended_time,
ROUND(EXTRACT(epoch FROM ended)) AS ended_epoch,
EXTRACT(epoch FROM ended-started) AS total_time,
ROUND(EXTRACT(epoch FROM now()-started)) AS total_time_started,
ROUND(EXTRACT(epoch FROM now()-ended)) AS total_time_ended
FROM syncrun
WHERE sync = ?
AND (   lastgood  IS TRUE
     OR lastbad   IS TRUE
     OR lastempty IS TRUE
     OR ended IS NULL)
};
    $sth = $dbh->prepare($SQL);

    ## Find the maximum lengths of items so we can line things up pretty
    my %max = (
        name      => 1,
        state     => 1,
        dit       => 1,
        lastgood  => 1,
        timegood  => 1,
        lastbad   => 1,
        timebad   => 1,
    );

    for my $sync (keys %$synclist) {

        my $s = $synclist->{$sync};

        ## Sometimes we only want some of them
        if ($arg->{syncs}) {
            next unless grep { $_ eq $sync } @{$arg->{syncs}}; ## no critic (ProhibitBooleanGrep)
        }

        $max{name} = length($sync) if length($sync) > $max{name};

        $count = $sth->execute($sync);
        if ($count < 1) {
            $sth->finish;
            $s->{state} = 'No records found';
            $max{state} = length($s->{state}) if length($s->{state}) > $max{state};
            next;
        }
        for my $row (@{ $sth->fetchall_arrayref({}) }) {
            if ($row->{lastgood}) {
                $s->{rowgood} = $row;
            }
            elsif ($row->{lastempty}) {
                $s->{rowempty} = $row;
            }
            elsif ($row->{lastbad}) {
                $s->{rowbad} = $row;
            }
            else {
                $s->{runningrow} = $row;
            }
        }

        ## What is the state of this sync? First, is it still actively running?
        if (exists $s->{runningrow}) {
            $s->{state} = "$s->{runningrow}{status}";
        }
        else {
            ## What was the most recent run?
            my $highepoch = 0;
            undef $s->{latestrow};
            my $wintype;
            for my $type (qw/ bad good /) {
                my $r = $s->{"row$type"};
                next if ! defined $r;
                my $etime = $r->{ended_epoch};
                if ($etime >= $highepoch) {
                    $s->{latestrow} = $r;
                    $highepoch = $etime;
                    $wintype = $type;
                }
            }
            if (! defined $s->{latestrow}) {
                $s->{state} = 'Unknown';
                $max{state} = length($s->{state}) if length($s->{state}) > $max{state};
                next;
            }
            $s->{state} =
                $wintype eq 'empty' ? 'Empty'
                : $wintype eq 'bad' ? 'Bad'
                : 'Good';
        }

        ## deletes/inserts/truncates/conflicts
        $s->{dit} = '';
        if (exists $s->{rowgood}) {
            $s->{dit} = "$s->{rowgood}{deletes}/$s->{rowgood}{inserts}";
            if ($s->{rowgood}{truncates}) {
                $max{truncates} = 1;
                $s->{dit} .= "/$s->{rowgood}{truncates}";
            }
            if ($s->{rowgood}{conflicts}) {
                $max{conflicts} = 1;
                $s->{dit} .= "/$s->{rowgood}{conflicts}";
            }
        }
        $s->{lastgood} = exists $s->{rowgood} ? $s->{rowgood}{ended_time} : 'none';
        $s->{timegood} = exists $s->{rowgood} ? pretty_time($s->{rowgood}{total_time_ended}) : '';
        $s->{lastbad} = exists $s->{rowbad} ? $s->{rowbad}{ended_time} : 'none';
        $s->{timebad} = exists $s->{rowbad} ? pretty_time($s->{rowbad}{total_time_ended}) : '';

        for my $var (qw/ state dit lastgood timegood lastbad timebad /) {
            $max{$var} = length($s->{$var}) if length($s->{$var}) > $max{$var};
        }

    }

    return $synclist, \%max;

} ## end of get_detailed_syncs


sub inspect {

    my $usage = usage('inspect');

    if (!@nouns) {
        warn "$usage\n";
        exit 1;
    }
    my $thing = shift @nouns;

    inspect_table() if $thing =~ /tab/i  or $thing eq 't';
    inspect_sync()  if $thing =~ /sync/i or $thing eq 's';
    inspect_herd()  if $thing =~ /herd/i or $thing eq 'h';

    warn "$usage\n";
    exit 1;

} ## end of inspect


sub inspect_table {

    my $usage = usage('inspect_table');

    if (! @nouns) {
        warn "$usage\n";
        exit 1;
    }

    $SQL = q{SELECT * FROM bucardo.goat WHERE tablename=?};
    my $sth_goat = $dbh->prepare($SQL);
    $SQL = q{SELECT * FROM bucardo.goat WHERE schemaname = ? AND tablename=?};
    my $sth_goat_schema = $dbh->prepare($SQL);
    my @tables;
    for my $name (@nouns) {
        my $sthg;
        if ($name =~ /(.+)\.(.+)/) {
            $sthg = $sth_goat_schema;
            $count = $sthg->execute($1,$2);
        }
        else {
            $sthg = $sth_goat;
            $count = $sthg->execute($name);
        }
        if ($count < 1) {
            die "Unknown table: $name\n";
        }

        for my $row (@{$sthg->fetchall_arrayref({})}) {
            push @tables, $row;
        }

    }

    for my $t (@tables) {
        my ($s,$t,$db,$id) = @$t{qw/schemaname tablename db id/};
        print "Inspecting $s.$t on $db\n";
        ## Grab all other tables referenced by this one
        my $tablist = get_reffed_tables($s,$t,$db);

        ## Check that each referenced table is in a herd with this table

        my %seenit;
        for my $tab (@$tablist) {
            my ($type,$tab1,$tab2,$name,$def) = @$tab;
            my $table = $type==1 ? $tab1 : $tab2;
            if ($table !~ /(.+)\.(.+)/) {
                die "Invalid table information\n";
            }
            my $schema = $1;
            $table = $2;
            next if $seenit{"$schema.$table.$type"}++;

            ## Make sure that each herd with this table also has this new table
            my $ggoat = $global{goat};
            my $hherd = $global{herd};
            for my $herd (sort keys %{$ggoat->{$id}{herd}}) {
                $seenit{fktable} = 1;
                next if exists $hherd->{$herd}{hasgoat}{$schema}{$table};
                printf "Table %s.%s is in herd %s, but %s.%s (used as FK%s) is not\n",
                    $s, $t, $herd, $schema, $table,
                        $type == 1 ? '' : ' target';

            }
            if (! exists $seenit{fktable}) {
                printf "Table %s.%s is used as FK%s by %s.%s\n",
                    $s,$t,$type==1 ? '' : ' target', $schema, $table;
                delete $seenit{fktable};
            }
        }
    }

    exit 0;

} ## end of inspect_table


sub inspect_herd {

    my $usage = usage('inspect_herd');

    if (! @nouns) {
        warn "$usage\n";
        exit 1;
    }

    die "Not implemented yet\n";

} ## end of inspect_herd


sub inspect_sync {

    my $usage = usage('inspect_sync');

    if (! @nouns) {
        warn "$usage\n";
        exit 1;
    }

    die "Not implemented yet\n";

} ## end of inspect_sync


sub get_reffed_tables {

    my ($s,$t,$db) = @_;

    my $rdbh = connect_database({name => $db});

    ## So we get the schemas
    $rdbh->do('SET search_path = pg_catalog');

    $SQL= q{
SELECT CASE WHEN conrelid=x.toid THEN 1 ELSE 2 END,
 confrelid::regclass,
 conrelid::regclass,
 conname,
 pg_get_constraintdef(oid, true)
FROM pg_constraint,
(SELECT c.oid AS toid FROM pg_class c JOIN pg_namespace n
   ON (n.oid=c.relnamespace) WHERE nspname=? AND relname=?
) x
WHERE contype = 'f' AND
(confrelid = x.toid OR conrelid = x.toid)
};

    $sth = $rdbh->prepare($SQL);
    $count = $sth->execute($s,$t);
    return $sth->fetchall_arrayref();

} ## end of get_reffed_tables




sub show_all_columns {

    my $row = shift or die;

    my $maxkey = 1;
    for my $key (keys %$row) {
        next if ref $row->{$key};
        $maxkey = length $key if length $key > $maxkey;
    }
    for my $key (sort {
        ($a eq 'src_code' and $b ne 'src_code' ? 1 : 0)
        or
        ($a ne 'src_code' and $b eq 'src_code' ? -1 : 0)
        or
        $a cmp $b } keys %$row
     ) {
        next if ref $row->{$key};
        printf "    %-*s = %s\n", $maxkey, $key,
            defined $row->{$key} ? $row->{$key} : 'NULL';
    }

    return;

} ## end of show_all_columns


sub process_args {

    ## Break apart a string of args, return a clean hashref

    my $string = shift or return {};
    $string .= ' ';

    my %arg;

    while ($string =~ m/(\w+)\s*=\s*"(.+?)" /g) {
        $arg{lc $1} = $2;
    }
    $string =~ s/\w+\s*=\s*".+?" / /g;

    while ($string =~ m/(\w+)\s*=\s*'(.+?)' /g) {
        $arg{lc $1} = $2;
    }
    $string =~ s/\w+\s*=\s*'.+?' / /g;

    while ($string =~ m/(\w+)\s*=\s*(\S+)/g) {
        $arg{lc $1} = $2;
    }
    $string =~ s/\w+\s*=\s*\S+/ /g;

    if ($string =~ /\S/) {
        $string =~ s/^\s+//;
        $arg{extraargs} = [split /\s+/ => $string];
    }

    ## Clean up and standardize the names
    if (exists $arg{type}) {
        $arg{type} =~ s/postgres.*/postgres/io;
        $arg{type} =~ s/drizzle.*/drizzle/io;
        $arg{type} =~ s/mongo.*/mongo/io;
        $arg{type} =~ s/mysql.*/mysql/io;
        $arg{type} =~ s/oracle.*/oracle/io;
        $arg{type} =~ s/redis.*/redis/io;
    }

    return \%arg;

} ## end of process_args



sub list {

    my $usage = usage('list');

    if (!@nouns) {
        warn "$usage\n";
        exit 1;
    }
    my $thing = shift @nouns;

    list_customcodes() if $thing =~ /^code/i or $thing =~ /^custom/i;
    list_dbgroups()    if $thing =~ /^dbg/i; ## Must come before the db check!
    list_databases()   if $thing =~ /^db/i or $thing =~ /^datab/i;
    list_herds()       if $thing =~ /^h/i;
    list_syncs()       if $thing =~ /^sy/i;
    list_tables()      if $thing =~ /^t/i;
    list_sequences()   if $thing =~ /^seq/i;

    warn "$usage\n";
    exit 1;

} ## end of list


sub list_customcodes {

    ## Show information about all or some subset of the 'customcode' table

    my $usage = usage('list_customcodes');

    ## Any nouns are filters against the whole list
    my $clause = generate_clause({col => 'name', items => \@nouns});
    my $WHERE = $clause ? "WHERE $clause" : '';
    $SQL = "SELECT * FROM bucardo.customcode $WHERE ORDER BY name";
    $sth = $dbh->prepare($SQL);
    $count = $sth->execute();
    if ($count < 1) {
        $sth->finish();
        printf "There are no%s entries in the 'customcode' table.\n",
            $WHERE ? ' matching' : '';
        exit 1;
    }

    $info = $sth->fetchall_arrayref({});

    my ($maxname,$maxwhen) = (1,1);
    for my $row (@$info) {
        $maxname = length $row->{name} if length $row->{name} > $maxname;
        $maxwhen = length $row->{whenrun} if length $row->{whenrun} > $maxwhen;
    }

    for my $row (@$info) {
        my $name = $row->{name};
        printf "Code: %-*s  When run: %-*s  Get dbh: %s  Get rows: %s Trigrules: %s\n",
            $maxname, $name,
            $maxwhen, $row->{whenrun},
            $row->{getdbh}, $row->{getrows}, $row->{trigrules};
        if (defined $row->{about} and $VERBOSE) {
            (my $about = $row->{about}) =~ s/(.)^/$1    /gsm;
            print "  About: $about\n";
        }
        $VERBOSE >= 2 and show_all_columns($row);
    }

    exit 0;

} ## end of list_customcodes







sub list_syncs {

    ## Show information about all or some subset of the 'sync' table
    ## Arguments are a list of syncs, or special modifiers
    ## Modifiers:
    ##  "active"
    ##  "inactive"

    my $usage = usage('list_syncs');

    my $syncs = $global{sync};

    ## Do we have at least one name specified (if not, show all)
    my $namefilter = 0;

    for my $term (@nouns) {

        ## Filter out by status: only show active or inactive syncs
        if ($term =~ /^(active|inactive)$/i) {
            my $stat = lc $1;
            for my $name (keys %$syncs) {
                delete $syncs->{$name} if $syncs->{$name}{status} ne $stat;
            }
            next;
        }

        ## Filter out by arbitrary attribute matches
        if ($term =~ /(\w+)\s*=\s*(\w+)/) {
            my ($attrib, $value) = (lc $1,$2);
            for my $name (keys %$syncs) {
                if (! exists $syncs->{$name}{$attrib}) {
                    my $msg = "No such sync attribute: $attrib\n";
                    $msg .= "Must be one of the following:\n";
                    my $names = join ',' =>
                        sort
                        grep { $_ !~ /\b(?:cdate|name)\b/ }
                        keys %{ $syncs->{$name} };
                    $msg .= " $names\n";
                    die $msg;
                }
                delete $syncs->{$name} if $syncs->{$name}{$attrib} ne $value;
            }
            next;
        }

        ## Everything else should be considered a sync name
        $namefilter = 1;

        ## Check for wildcards
        if ($term =~ s/[*%]/.*/) {
            for my $name (keys %$syncs) {
                $syncs->{$name}{ok2show} = 1 if $name =~ /$term/;
            }
            next;
        }

        ## Must be an exact match
        for my $name (keys %$syncs) {
            $syncs->{$name}{ok2show} = 1 if $name eq $term;
        }

    }

    ## If we filtered by name, remove all the non-matched ones
    if ($namefilter) {
        for my $name (keys %$syncs) {
            delete $syncs->{$name} if ! exists $syncs->{$name}{ok2show};
        }
    }

    ## Nothing found? We're out of here
    if (! keys %$syncs) {
        print "No syncs found\n";
        exit 1;
    }

    ## Determine the size of the output strings for pretty aligning later
    my ($maxname, $maxherd, $maxdbs) = (2,2,2);
    for my $name (keys %$syncs) {
        my $s = $syncs->{$name};
        $maxname = length $name if length $name > $maxname;
        $maxherd = length $s->{herd}{name} if length $s->{herd}{name} > $maxherd;
        $s->{d} = 'DBs:';
        for (sort keys %{ $s->{dblist} }) {
            $s->{d} .= " $_ ($s->{dblist}{$_}{role})";
        }
        $maxdbs = length $s->{d} if length $s->{d} > $maxdbs;
    }

    ## Now print them out in alphabetic order
    ## TODO: Have a CSV like output
    for my $name (sort keys %$syncs) {
        my $s = $syncs->{$name};

        ## Switch to multi-line if database info strings are over this
        my $maxdbline = 50;

        ## Show basic information
        printf "Sync: %-*s  Herd: %-*s %s[%s]\n",
            $maxname, $name,
            $maxherd, $s->{herd}{name},
            $maxdbs > $maxdbline ? '' : "$s->{d}  ",
            ucfirst $s->{status};

        ## Print the second line if needed
        if ($maxdbs > $maxdbline) {
            print "  $s->{d}\n";
        }

        ## Show associated tables if in verbose mode
        if ($VERBOSE >= 1) {
            if (exists $s->{herd}{goat}) {
                my $goathash = $s->{herd}{goat};
                for my $relname (sort {
                                     $goathash->{$b}{priority} <=> $goathash->{$a}{priority}
                                     or $a cmp $b
                                   }
                              keys %{ $goathash }) {
                    printf "  %s %s\n",
                        ucfirst($goathash->{$relname}{reltype}),$relname;
                }
            }
        }

        ## Show all the sync attributes
        $VERBOSE >= 2 and show_all_columns($s);

    } ## end of each sync

    exit 0;

} ## end of list_syncs


sub list_tables {

    ## Show information about all or some tables in the 'goat' table

    my $usage = usage('list_tables');

    my $clause = generate_clause({col => 'tablename', items => \@nouns});
    my $WHERE = $clause ? "AND $clause" : '';
    $SQL = "SELECT * FROM bucardo.goat WHERE reltype='table' $WHERE ORDER BY schemaname, tablename";
    $sth = $dbh->prepare($SQL);
    $count = $sth->execute();
    if ($count < 1) {
        $sth->finish();
        printf "There are no%s entries in the 'goat' table.\n",
            $WHERE ? ' matching' : '';
        exit 1;
    }

    $info = $sth->fetchall_arrayref({});

    ## Are we showing verbose information? Get matching herds
    my ($maxtable,$maxdb,$maxpkey) = (1,1,1);
    for my $row (@$info) {
        my $name = "$row->{schemaname}.$row->{tablename}";
        $maxtable = length $name if length $name > $maxtable;
        $name = $row->{pk} = $row->{pkey} ? "$row->{pkey} ($row->{pkeytype})" : 'none';
        $maxpkey = length $name if length $name > $maxpkey;
        $maxdb = length $row->{db} if length $row->{db} > $maxdb;
    }

    for my $row (sort numbered_relations @$info) {

        ## Extra information of note to tack on the end
        my $extra = '';
        if (defined $row->{ping}) {
            $extra .= sprintf ' ping:%s', $row->{ping} ? 'true' : 'false';
        }
        if ($row->{rebuild_index} != 0) {
            $extra .= " rebuild_index:$row->{rebuild_index}";
        }

        printf "Table: %-*s  DB: %-*s  PK: %s%s\n",
            $maxtable, "$row->{schemaname}.$row->{tablename}",
            $maxdb, $row->{db},
            $row->{pk},
            $extra;
        if ($VERBOSE) {
            my $g = $global{goat}->{$row->{id}};
            if (exists $g->{herd}) {
                print '  Belongs to herds: ';
                print join ', ' => sort keys %{$g->{herd}};
                print "\n";
                my %syncs;
                for my $herd (keys %{$g->{herd}}) {
                    my $h = $global{herd}->{$herd};
                    for my $s (keys %{$h->{sync}}) {
                        $syncs{$s}++;
                    }
                }
                if (keys %syncs) {
                    print '  Belongs to syncs: ';
                    print join ', ' => sort keys %syncs;
                    print "\n";
                }
            }
        }

        $VERBOSE >= 2 and show_all_columns($row);

    }

    exit 0;

} ## end of list_tables


sub list_sequences {

    ## Show information about all or some sequences in the 'goat' table

    my $usage = usage('list_sequences');

    my $clause = generate_clause({col => 'tablename', items => \@nouns});
    my $WHERE = $clause ? "AND $clause" : '';
    $SQL = "SELECT * FROM bucardo.goat WHERE reltype = 'sequence' $WHERE ORDER BY schemaname, tablename";
    $sth = $dbh->prepare($SQL);
    $count = $sth->execute();
    if ($count < 1) {
        $sth->finish();
        printf "There are no%s entries in the 'goat' table.\n",
            $WHERE ? ' matching' : '';
        exit 1;
    }

    $info = $sth->fetchall_arrayref({});
    my $maxq = 1;
    for my $row (@$info) {
        my $len = length "$row->{schemaname}.$row->{tablename}";
        $maxq = $len if $len > $maxq;
    }

    for my $row (@$info) {
        printf "Sequence: %-*s  DB: %s\n",
            $maxq, "$row->{schemaname}.$row->{tablename}",
              $row->{db};
        $VERBOSE >= 2 and show_all_columns($row);
    }


    exit 0;

} ## end of list_sequences


sub pretty_time {

    my $secs = shift;

    $secs = ceil($secs);

    return '?' if ! defined $secs or $secs !~ /^\-?\d+$/o or $secs < 0;
    my ($D,$H,$M,$S) = (0,0,0,0);

    if ($bcargs->{showdays}) {
        if ($secs > 60*60*24) {
            $D = int $secs/(60*60*24);
            $secs -= $D*60*60*24;
        }
    }
    if ($secs > 60*60) {
        $H = int $secs/(60*60);
        $secs -= $H*60*60;
    }
    if ($secs > 60) {
        $M = int $secs/60;
        $secs -= $M*60;
    }
    $secs = int $secs;
    my $answer = sprintf "%s%s%s${secs}s",$D ? "${D}d " : '',$H ? "${H}h " : '',$M ? "${M}m " : '';

    ## Detailed listings get compressed
    if ((defined $COMPRESS and $COMPRESS) or (!defined $COMPRESS and !@nouns)) {
        $answer =~ s/ //g;
    }
    return $answer;

} ## end of pretty_time


sub pretty_number {

    ## Format a raw number in a more readable style

    my $number = shift;

    return $number if $number !~ /^\d+$/ or $number < 1000;

    ## If this is our first time here, find the correct separator
    if (! defined $bcargs->{tsep}) {
        my $lconv = localeconv();
        $bcargs->{tsep} = $lconv->{thousands_sep} || ',';
    }

    ## No formatting at all
    return $number if '' eq $bcargs->{tsep} or ! $bcargs->{tsep};

    (my $reverse = reverse $number) =~ s/(...)(?=\d)/$1$bcargs->{tsep}/g;
    $number = reverse $reverse;
    return $number;

} ## end of pretty_number


sub get_syncs {

    my %dbgroup;
    $SQL = 'SELECT dbgroup, db FROM bucardo.dbmap ORDER BY priority, db';
    for my $row (@{$dbh->selectall_arrayref($SQL)}) {
        push @{$dbgroup{$row->[0]}}, $row->[1];
    }

    $SQL = q{
        SELECT *,
            COALESCE(EXTRACT(epoch FROM checktime),0) AS checksecs,
            now()-overdue AS overdue_time,
            now()-expired AS expired_time,
            extract(epoch FROM overdue) AS overdue_secs,
            extract(epoch FROM expired) AS expired_secs
        FROM     bucardo.sync
        ORDER BY priority DESC, name DESC
    };
    $sth = $dbh->prepare($SQL);
    $sth->execute();
    my $sync = $sth->fetchall_hashref('name');

    ## Expand any targetgroups in use
    for (keys %$sync) {
        my $s = $sync->{$_};
        if (defined $s->{targetgroup}) {
            $s->{targets} = $dbgroup{$s->{targetgroup}};
        }
    }

    ## Check what exists in the pid directory
    opendir my $sdir, $PIDDIR or return $sync;

    my $syncpidfile;
    while (defined ($syncpidfile = readdir($sdir))) {
        next if $syncpidfile =~ /^\.\.?$/
            or "$PIDDIR/$syncpidfile" eq $STOPFILE
            or "$PIDDIR/$syncpidfile" eq $PIDFILE;
        if ($syncpidfile !~ /^bucardo\.ctl\.sync\.(.+)\.pid$/) {
            next;
        }
        my $syncname = $1; ## no critic (ProhibitCaptureWithoutTest)

        ## Is this a valid syncname?
        if (! exists $sync->{$syncname}) {
            warn qq{Invalid pid file found: $PIDDIR/$syncpidfile - removing it\n};
            unlink "$PIDDIR/$syncpidfile";
            next;
        }

        my $cdate = localtime ($^T - (-C "$PIDDIR/$syncpidfile")*24*60*60);
        $sync->{$syncname}{PIDFILE} = "$PIDDIR/$syncpidfile";
        $sync->{$syncname}{CREATED} = $cdate;

        ## Does it contain a pid?
        open my $fh, '<', "$PIDDIR/$syncpidfile" or die qq{Could not open "$PIDDIR/$syncpidfile": $!\n};
        my $pid = <$fh>;
        chomp $pid;
        if (! defined $pid) { $pid = ''; }
        close $fh or warn qq{Could not close $PIDDIR/$syncpidfile: $!\n};
        if ($pid !~ /^\d+$/) {
            $sync->{$syncname}{NOPID} = 1;
        }
        else {
            $sync->{$syncname}{PID} = $pid;
            $sync->{$syncname}{PIDPING} = kill 0, $pid;
        }
    }
    return $sync;

} ## end of get_syncs


sub vate_sync {

    my $name = lc $verb;
    my $ucname = ucfirst $name;
    @nouns or die qq{${name}_sync requires at least one sync name\n};

    my $wait = (defined $adverb and $adverb eq '0') ? 1 : 0;
    for my $sync (@syncs) {
        (my $vname = $ucname) =~ s/e$/ing/;
        $QUIET or print qq{$vname sync $sync};
        my $done = "bucardo_${name}d_sync_$sync";
        $dbh->do(qq{NOTIFY "bucardo_${name}_sync_$sync"});
        if ($wait) {
            print '...';
            $dbh->do(qq{LISTEN "$done"});
        }
        $dbh->commit();
        if (!$wait) {
            print "\n";
            next;
        }
        sleep 0.1;
        wait_for_notice($dbh, $done);
        print "OK\n";
    } ## end each sync
    exit 0;

} ## end of vate_sync


sub add_item {

    my $self = shift;

    my $usage = usage('add');

    if (!@nouns) {
        warn "$usage\n";
        exit 1;
    }

    ## First word must be a type we know about
    my $type = shift @nouns;
    $type = lc $type;

    ## Allow plurals
    $type =~ s/s$//;

    ## In case we used 'all'
    my $type2 = $nouns[0] || '';

    if ($type eq 'code' or $type eq 'customcode' or $type eq 'custom_code') {
        add_customcode();
    }
    elsif ($type eq 'db' or $type eq 'database') {
        add_database();
    }
    elsif ($type eq 'dbgroup' or $type eq 'dbg') {
        add_dbgroup();
    }
    elsif ($type eq 'herd') {
        add_herd();
    }
    elsif ($type eq 'table') {
        if ($type2 eq 'all') {
            shift @nouns;
            print add_all_tables();
            $dbh->commit();
        }
        else {
            add_table('table');
        }
    }
    elsif ($type eq 'sequence') {
        if ($type2 eq 'all') {
            shift @nouns;
            print add_all_sequences();
            $dbh->commit();
        }
        else {
            add_table('sequence');
        }
    }
    elsif ($type eq 'sync') {
        add_sync();
    }
    elsif ($type eq 'all') {
        if ($type2 =~ /table/i) {
            shift @nouns;
            print add_all_tables();
            $dbh->commit();
            exit 0;
        }
        elsif ($type2 =~ /sequence/i) {
            shift @nouns;
            print add_all_sequences();
            $dbh->commit();
            exit 0;
        }
        else {
            warn qq{The 'all' option can only be used with 'table' and 'sequence'\n};
            exit 1;
        }
    }
    else {
        warn usage('add') . "\n";
        exit 1;
    }
    exit 0;

} ## end of add_item















sub add_customcode {

    my $item_name = shift @nouns || '';

    my $usage = usage('add_customcode');

    if (!length $item_name) {
        warn "$usage\n";
        exit 1;
    }

    ## Inputs and aliases, database column name, flags, default
    my $whenrunlist = 'before_txn before_check_rows before_trigger_drop after_trigger_drop'
        . ' after_table_sync exception conflict before_trigger_enable after_trigger_enable'
        . ' after_txn before_sync after_sync';
    my $whenrun = join '|' => split /\s+/ => $whenrunlist;
    my $validcols = qq{
        name                     name                 0                $item_name
        about                    about                0                null
        whenrun|when_run         whenrun              =$whenrun        null
        getdbh                   getdbh               TF               null
        getrows                  getrows              TF               null
        trigrules                trigrules            TF               null
        sync                     sync                 0                skip
        goat                     goat                 0                skip
        active                   active               TF               skip
        priority                 priority             number           skip
        src_code                 src_code             0                skip
    };

    my ($dbcols,$cols,$phs,$vals)
        = process_simple_args({cols => $validcols, list => \@nouns, usage => $usage});

    my $newname = $dbcols->{name};

    ## Does this already exist?
    if (exists $global{cc}{$newname}) {
        warn qq{Cannot create: customcode "$newname" already exists\n};
        exit 2;
    }

    ## We must have a "whenrun"
    if (! $dbcols->{whenrun}) {
        warn "$usage\n";
        exit 1;
    }

    ## We must have a src_code as a file
    if (! exists $dbcols->{src_code} or ! $dbcols->{src_code}) {
        warn "$usage\n";
        exit 1;
    }
    my $tfile = $dbcols->{src_code};
    if (! -e $tfile) {
        warn qq{Could not find a file named "$tfile"\n};
        exit 2;
    }
    open my $fh, '<', $tfile or die qq{Could not open "$tfile": $!\n};
    my $src = '';
    { local $/; $src = <$fh>; } ## no critic (RequireInitializationForLocalVars)
    close $fh or warn qq{Could not close "$tfile": $!\n};

    ## Attempt to insert this into the database
    $SQL = "INSERT INTO bucardo.customcode ($cols,src_code) VALUES ($phs,?)";
    $DEBUG and warn "SQL: $SQL\n";
    $DEBUG and warn Dumper $vals;
    $sth = $dbh->prepare($SQL);
    eval {
        $count = $sth->execute(@$vals, $src);
    };
    if ($@) {
        die "Failed to add customcode: $@\n";
    }

    my $finalmsg = '';

    ## See if any updates to customcode_map need to be made

    ## Only one of sync or goat can be specified
    if ($dbcols->{sync} and $dbcols->{goat}) {
        die qq{Sorry, you must specify a sync OR a goat, not both\n};
    }

    ## Makes no sense to specify priority or active if no goat or sync
    if (($dbcols->{priority} or $dbcols->{active}) and !$dbcols->{sync} and ! $dbcols->{goat}) {
        die qq{You must specify a sync or a goat when using priority or active\n};
    }

    ## Is this a valid sync?
    if ($dbcols->{sync} and ! exists $global{sync}{$dbcols->{sync}}) {
        die qq{Unknown sync: $dbcols->{sync}\n};
    }

    ## Is this a valid gaot?
    if ($dbcols->{goat} and ! exists $global{goat}{$dbcols->{goat}}) {
        die qq{Unknown goat: $dbcols->{goat}\n};
    }

    ## Add to the customcode_map table
    if ($dbcols->{sync} or $dbcols->{goat}) {
        $SQL = 'INSERT INTO customcode_map(code,';
        my @vals;
        for my $col (qw/sync goat priority active/) {
            if ($dbcols->{$col}) {
                $SQL .= "$col,";
                push @vals => $dbcols->{$col};
            }
        }
        my $phs2 = '?,' x @vals;
        $SQL .= ") VALUES ((SELECT currval('customcode_id_seq')),$phs2)";
        $SQL =~ s/,\)/)/g;
        $sth = $dbh->prepare($SQL);
        eval {
            $count = $sth->execute(@vals);
        };
        if ($@) {
            die "Failed to add customcode_map: $@\n";
        }
    }

    $dbh->commit();

    if (!$QUIET) {
        print qq{Added customcode "$newname"\n};
        $finalmsg and print $finalmsg;
    }

    exit 0;

} ## end of add_customcode














sub add_sync {

    my $item_name = shift @nouns || '';

    my $usage = usage('add_sync');

    my $batch = 1;

    if (!length $item_name) {
        warn "$usage\n";
        exit 1;
    }

    ## Inputs and aliases, database column name, flags, default
    my $validcols = qq{
        name                     name                 0                $item_name
        herd                     herd                 0                null
        dbs                      dbs                  0                null
        stayalive                stayalive            TF               null
        kidsalive                kidsalive            TF               null
        limitdbs                 limitdbs             numeric          null
        ping                     ping                 TF               null
        do_listen                do_listen            TF               null
        checktime                checktime            interval         null
        status                   status               =active|inactive null
        source_makedelta         source_makedelta     =inherits|on|off null
        target_makedelta         target_makedelta     =inherits|on|off null
        priority                 priority             numeric          null
        analyze_after_copy       analyze_after_copy   TF               null
        overdue                  overdue              interval         null
        expired                  expired              interval         null
        track_rates              track_rates          TF               null
        onetimecopy              onetimecopy          =0|1|2           null
        lifetime                 lifetime             interval         null
        maxkicks                 maxkicks             numeric          null
        rebuild_index|rebuildindex   rebuild_index    numeric          null
        customselect|usecustomselect usecustomselect  TF               null
        tables                   tables               0                skip
    };

    ## Fullcopy syncs get some of their defaults overriden
    ## Because who wants ping on a fullcopy sync?

    my $morph = [
        {
            field => 'synctype',
            value => 'fullcopy',
            new_defaults => 'ping|F stayalive|F kidsalive|F'
        },
    ];

    my ($dbcols,$cols,$phs,$vals)
        = process_simple_args({cols => $validcols, list => \@nouns, usage => $usage, morph => $morph});

    if (! exists $dbcols->{herd}) {
        ## But allow on-the-fly herd creation
        die "Need to specify a herd for this sync\n";
    }
    if (! exists $dbcols->{dbs}) {
        die "Need to specify which databases\n";
    }

    ## Already got a sync by this name?
    if (exists $global{sync}{$item_name}) {
        die qq{A sync with the name "$item_name" already exists\n};
    }

    ## If this is a list of tables, create them as a new herd
    ## Ideally we also re-use the herd if it already exists
    if ($dbcols->{herd} =~ /,/) {
        my @tables = split /\s*,\s*/ => $dbcols->{herd};
        for my $table (sort @tables) {
            if (! exists $global{goat}{$table}) {
                die "No such table or sequence: $table\n";
            }
        }
    }
    else {
        my $name = $dbcols->{herd};
        if (! exists $global{herd}{$name}) {
            my $schema = 'public';

            ## Maybe it's a table?
            if (! exists $global{goat}{$name}) {
                warn "No such herd or table: $name\n";
                warn "To list all herds, use: list herds\n";
                warn "To list all tables, use: list tables\n";
                exit 1;
            }

            ## See if any existing herds match this one
            for my $hname (sort keys %{$global{herd}}) {
                my $number = keys %{$global{herd}{$hname}{hasgoat}{$schema}};
                next unless 1 == $number;
                print qq{Use existing herd "$hname"? Y/N };
                my $ans = $batch ? 'Y' : <STDIN>;
                if ($ans =~ /^y/i) {
                    $dbcols->{herd} = $hname;
                    $vals->{herd} = $hname;
                    last;
                }
            }
            ## If we aren't using an existing herd, create a new one
            $name = $dbcols->{herd};
            if (! exists $global{herd}{$name}) {
                print "Create a new herd with table $name\n";

                ## We will use the name of the sync if free
                ## Otherwise, keep adding numbers to it until we get a free name
                $SQL = 'SELECT 1 FROM bucardo.herd WHERE name = ?';
                $sth = $dbh->prepare($SQL);
                my $gname = $item_name;
                my $x = 1;
                {
                    $count = $sth->execute($gname);
                    $sth->finish();
                    last if $count < 1;
                    $gname  = "${item_name}_$x";
                    $x++;
                    redo;
                }
                $SQL = "INSERT INTO bucardo.herd (name) VALUES (?)";
                $sth = $dbh->prepare($SQL);
                $count = $sth->execute($gname);
                if (1 != $count) {
                    die qq{Unable to add new herd named "$gname"\n};
                }
                $SQL = 'INSERT INTO bucardo.herdmap(herd,goat) VALUES (?,'
                    . '(SELECT id FROM bucardo.goat WHERE schemaname = ? AND tablename = ?))';
                $sth = $dbh->prepare($SQL);
                $count = $sth->execute($gname, $schema, $name);
                if (1 != $count) {
                    die qq{Unable to add table "$name" to herd "$gname"\n};
                }
                print qq{Created herd "$gname"\n};
                $dbcols->{herd} = $gname;

            }
        } ## end no herd name match

    } ## end single word herd option

    ## Next, the dbs

    ## If this is a single database, turn into a "list" for below
    if (exists $global{db}{$dbcols->{dbs}}) {
        $dbcols->{dbs} .= ',';
    }

    ## Can be a database group, or a list of databases
    if ($dbcols->{dbs} =~ /,/) {
        my @dbs = split /\s*,\s*/ => $dbcols->{dbs};
        my %db;
        my $type = '';
        for my $db (sort @dbs) {
            ## Set the default type of database
            $type = $type eq '' ? 'source' : 'target';
            if ($db =~ s/=(.+)//) {
                $type = $1;
            }
            if (! exists $global{db}{$db}) {
                die "No such database: $db\n";
            }
            ## Standardize and check the types
            $type = 'source' if $type =~ /^s/i;
            $type = 'target' if $type =~ /^t/i;
            $type = 'fullcopy' if $type =~ /^f/i;
            if ($type !~ /^(source|target|fullcopy)$/) {
                die "Invalid database type: must be source, target, or fullcopy\n";
            }
            $db{$db} = $type;
        }
        ## Do any existing groups match this list exactly?
        my $newlist = join ',' => map { "$_=".$db{$_} } sort keys %db;
        for my $gname (sort keys %{$global{dbgroup}}) {
            my $innerjoin = join ',' => map { "$_=".$global{dbgroup}{$gname}{db}{$_} } sort keys %{$global{dbgroup}{$gname}{db}};
            if ($innerjoin eq $newlist) {
                print qq{That group of databases already exists as dbgroup "$gname"\n};
                print qq{Do you wish to use that group instead? Y/N };
                my $ans = $batch ? 'Y' : <STDIN>;
                if ($ans =~ /^y/i) {
                    $dbcols->{dbs} = $gname;
                    $vals->{dbs} = $gname;
                    last;
                }
                ## Don't ask again?
                $newlist = '';
            }
        }

        if ($dbcols->{dbs} =~ /,/) { ## Make sure we still have a list
            ## We will use the name of the sync if free
            ## Otherwise, keep adding numbers to it until we get a free name
            $SQL = 'SELECT 1 FROM bucardo.dbgroup WHERE name = ?';
            $sth = $dbh->prepare($SQL);
            my $gname = $item_name;
            my $x = 1;
            {
                $count = $sth->execute($gname);
                $sth->finish();
                last if $count < 1;
                $gname  = "${item_name}_$x";
                $x++;
                redo;
            }
            $SQL = "INSERT INTO bucardo.dbgroup (name) VALUES (?)";
            $sth = $dbh->prepare($SQL);
            $count = $sth->execute($gname);
            if (1 != $count) {
                die qq{Unable to add new dbgroup named "$gname"\n};
            }
            $SQL = 'INSERT INTO bucardo.dbmap(dbgroup,db,role) VALUES (?,?,?)';
            $sth = $dbh->prepare($SQL);
            for my $db (sort keys %db) {
                $count = $sth->execute($gname, $db, $db{$db});
                if (1 != $count) {
                    die qq{Unable to add database "$db" to group "$gname"\n};
                }
            }
            print qq{Created database group "$gname"\n};
            $dbcols->{dbs} = $gname;
            $vals->{dbs} = $gname;
        }
    } ## end of multiple databases specified
    else {
        my $dbg = $dbcols->{dbs};
        if (! exists $global{dbgroup}{$dbg}) {
            warn "No such database group: $dbg\n";
            warn "To list all database groups, use: list dbgroups\n";
            exit 1;
        }
    }

    $dbh->commit();

    ## Attempt to insert this into the database
    $SQL = "INSERT INTO bucardo.sync ($cols) VALUES ($phs)";
    $DEBUG and warn "SQL: $SQL\n";
    $DEBUG and warn Dumper $vals;
    $sth = $dbh->prepare($SQL);
    my @flatvals = map { $vals->{$_} } sort keys %$vals;
    $DEBUG and warn Dumper \@flatvals;
    eval {
        $count = $sth->execute(@flatvals);
    };
    if ($@) {
        die "Failed to add sync: $@\n";
    }

    $dbh->commit();

    if (!$QUIET) {
        print qq{Added sync "$item_name"\n};
    }

    exit 0;

} ## end of add_sync



sub find_goats_in_db {

    ## Given a database name and one or more table strings, return all matches
    ## This version does *not* add them!

    my $dbname = shift or die;
    print qq{Checking inside database "$dbname" for some matching goats\n};

    ## Get connection to this database
    my $dbh = connect_database($dbname);

    my @names = @_;

    for my $name (@names) {
        print "Looking for name $name\n";
        ## Table vs sequence?
        my @items = find_relnames($dbh, $name);
    }



    return;

} ## end of find_goats_in_db


sub find_relnames {

    ## Given a db handle and a name, return all matching relnames
    ## Returns relkind, nspname, and relname

    my $dbh = shift or die;
    my $name = shift or die;

    ## Is this a wildcard etc. etc.

    return;


} ## end of find_relnames


sub _list_databases {

    return if ! keys %{ $DB };
    warn "The following databases are available:\n";
    for (sort keys %{ $DB }) {
        next if $DB->{$_}{dbtype} ne 'postgres';
        print "$_\n";
    }
    return;

} ## end of _list_databases


sub add_all_tables {
    return add_all_goats('table');
}

sub add_all_sequences {
    return add_all_goats('sequence');
}


sub add_all_goats {

    my $type = shift;

    ## Usage: add all table(s) | add all sequence(s)
    ## Options:
    ## --db: use this database (internal name from the db table)
    ## --schema or -n: limit to one or more comma-separated schemas
    ## --exclude-schema or -N: exclude these schemas
    ## --table or -t: limit to the given tables
    ## --exclude-table or -t: exclude these tables
    ## --herd: name of the herd to add new tables to
    ## pkonly: exclude tables with no pkey
    ## Returns: text string of results, with a newline

    ## Transform command-line args to traditional format
    ## e.g. db=foo becomes the equivalent of --db=foo
    ## foo becomes foo=1
    for my $noun (@nouns) {
        if ($noun =~ /(\w+)=(\w+)/) {
            $bcargs->{$1} = $2;
        }
        else {
            $bcargs->{$noun} = 1;
        }
    }

    ## Grab the list of databases. If none, cowardly refuse to continue
    my $dbs = get_dbs();
    if (! keys %$dbs) {
        die "Sorry, cannot add any ${type}s until at least one database has been added\n";
    }

    ## If there is more than one database, it must be selected via db=
    my $db;
    my $showdbs = 0;
    if (exists $bcargs->{db}) {
        if (! exists $dbs->{$bcargs->{db}}) {
            warn qq{Sorry, could not find a database named "$bcargs->{db}"\n};
            $showdbs = 1;
        }
        else {
            $db = $dbs->{$bcargs->{db}};
        }
    }
    elsif (keys %$dbs == 1) {
        ($db) = values %$dbs;
    }
    else {
        warn "Please specify which database to use with the db=<name> option\n";
        $showdbs = 1;
    }

    if ($showdbs) {
        _list_databases();
        exit 1;
    }

    ## Connect to the remote database
    my $dbh2 = connect_database({name => $db->{name}});

    ## Query to pull all tables we may possibly need
    my $kind = $type eq 'table' ? 'r' : 'S';
    $SQL = q{SELECT nspname, relname FROM pg_catalog.pg_class c }
        . q{JOIN pg_catalog.pg_namespace n ON (n.oid = c.relnamespace) }
        . qq{WHERE relkind = '$kind' };

    ## We always exclude information_schema, system, and bucardo schemas
    $SQL .= q{AND n.nspname <> 'information_schema' AND nspname !~ '^pg' AND nspname !~ '^bucardo'};

    my @clause;

    ## If they gave a schema option, restrict the query by namespace
    push @clause => generate_clause({col => 'nspname', items => [$bcargs->{schema}]});

    ## If they have asked to exclude schemas, append that to the namespace clause
    push @clause => generate_clause({col => 'nspname', items => [$bcargs->{'exclude-schema'}], not => 1});

    ## If they gave a table option, restrict the query by relname
    push @clause => generate_clause({col => 'relname', items => [$bcargs->{table}]});

    ## If they have asked to exclude tables, append that to the relname clause
    push @clause => generate_clause({col => 'relname', items => [$bcargs->{'exclude-table'}], not => 1});

    for my $c (@clause) {
        next if ! $c;
        $SQL .= "\nAND ($c)";
    }

    ## Fetch all the items, warn if no matches are found
    $VERBOSE >= 2 and warn "Query: $SQL\n";
    $sth = $dbh2->prepare($SQL);
    $count = $sth->execute();
    if ($count < 1) {
        warn "Sorry, no ${type}s were found\n";
    }

    ## Grab all current tables or sequences from the goat table.
    $SQL = qq{SELECT schemaname, tablename FROM bucardo.goat WHERE reltype= '$type' AND db = '$db->{name}'};
    my %hastable;
    for my $row (@{$dbh->selectall_arrayref($SQL)}) {
        $hastable{$row->[0]}{$row->[1]}++;
    }

    ## Do we have a herd request? Process it if so
    my $herd = '';
    my $addtoherd;
    if (exists $bcargs->{herd}) {
        $herd = $bcargs->{herd};
        $SQL = 'SELECT 1 FROM bucardo.herd WHERE name = ?';
        my $herdcheck = $dbh->prepare($SQL);
        $count = $herdcheck->execute($herd);
        $herdcheck->finish();
        if ($count < 1) {
            print "Creating herd: $herd\n";
            $SQL = 'INSERT INTO bucardo.herd(name) VALUES (?)';
            $herdcheck = $dbh->prepare($SQL);
            $herdcheck->execute($herd);
        }
        else {
            $VERBOSE >= 1 and warn "Herd already exists: $herd\n";
        }
        $SQL = 'INSERT INTO bucardo.herdmap(herd,goat) VALUES (?,?)';
        $addtoherd = $dbh->prepare($SQL);
    }

    ## Get ready to add tables or sequences to the goat table
    $SQL = q{INSERT INTO bucardo.goat (db,schemaname,tablename,reltype) VALUES (?,?,?,?)};
    my $addtable = $dbh->prepare($SQL);

    ## Walk through all returned tables from the remote database
    my %count = (seenit => 0, added => 0);
    my (%old, %new, %fail, $id);
    for my $row (@{$sth->fetchall_arrayref()}) {
        my ($S,$T) = @$row;
        my $tinfo;
        ## Do we already have this one?
        if (exists $hastable{$S}{$T}) {
            $VERBOSE >= 2 and warn "Skipping $type already in goat: $S.$T\n";
            $count{seenit}++;
            $old{$S}{$T} = 1;
            if ($herd and 'table' eq $type) {
                ## In case this is not already in the herd, grab the id and jump down
                $SQL = 'SELECT * FROM goat WHERE db=? AND schemaname=? AND tablename=? AND reltype=?';
                $sth = $dbh->prepare($SQL);
                $count = $sth->execute($db->{name},$S,$T,'table');
                if ($count < 1) {
                    die qq{Could not find table $S.$T in database "$db->{name}"!\n};
                }
                $tinfo = $sth->fetchall_arrayref({})->[0];
                $id = $tinfo->{id};
                goto HERD;
            }
            next;
        }
        $VERBOSE >= 2 and warn "Attempting to add $S.$T to the goat table\n";
        eval {
            $count = $addtable->execute($db->{name},$S,$T,$type);
        };
        if ($@) {
            warn "$@\n";
            if ($@ =~ /prepared statement.+already exists/) {
                warn "This message usually indicates you are using pgbouncer\n";
                warn "You can probably fix this problem by running:\n";
                warn "$progname update db $db->{name} server_side_prepares=false\n";
                warn "Then retry your command again\n\n";
            }
            exit 1;
        }
        if ($count != 1) {
            $addtable->finish();
            warn "Failed to add $type $S.$T to the goat table!\n";
            $fail{$S}{$T} = 1;
            next;
        }
        $SQL = q{SELECT currval('bucardo.goat_id_seq')};
        $id = $dbh->selectall_arrayref($SQL)->[0][0];
        $VERBOSE >= 2 and warn "ID of new table $S.$T is $id\n";

        $count{added}++;
        $new{$S}{$T} = 1;
      HERD:
        if ($herd) {
            if (! defined $tinfo) {
                $SQL = 'SELECT * FROM goat WHERE id = ?';
                $sth = $dbh->prepare($SQL);
                $sth->execute($id);
                $tinfo = $sth->fetchall_arrayref({})->[0];
            }
            if ($bcargs->{pkonly} and 'table' eq $type and ! length $tinfo->{pkey}) {
                warn "Not adding table $S.$T to herd: no pkey\n";
            }
            else {
                $SQL = 'SELECT 1 FROM herdmap WHERE herd=? AND goat = ?';
                $sth = $dbh->prepare($SQL);
                $count = $sth->execute($herd, $id);
                if ($count < 1) {
                    $addtoherd->execute($herd, $id);
                    $VERBOSE >= 2 and warn "Added $type $S.$T to herd $herd\n";
                }
            }
        }

    }

    ## Disconnect from the remote database
    $dbh2->disconnect();

    if ($VERBOSE >= 1) {
        if (%new) {
            print "New ${type}s:\n";
            for my $s (sort keys %new) {
                for my $t (sort keys %{$new{$s}}) {
                    print "  $s.$t\n";
                }
            }
        }
        if (%fail) {
            print "Failed to add ${type}s:\n";
            for my $s (sort keys %fail) {
                for my $t (sort keys %{$fail{$s}}) {
                    print "  $s.$t\n";
                }
            }
        }
    }

    return "New ${type}s added: $count{added}\nAlready added: $count{seenit}\n";

} ## end of add_all_goats


sub remove_item {

    my $self = shift;

    my $usage = usage('remove');

    if (!@nouns) {
        warn "$usage\n";
        exit 1;
    }

    ## First word must be a type we know about
    my $type = shift @nouns;
    $type = lc $type;

    if ($type eq 'code' or $type eq 'customcode' or $type eq 'custom_code') {
        remove_customcode();
    }
    elsif ($type eq 'd' or $type eq 'db' or $type eq 'database') {
        remove_database();
    }
    elsif ($type eq 'herd') {
        remove_herd();
    }
    elsif ($type eq 'table') {
        remove_table();
    }
    elsif ($type eq 'sequence') {
        remove_table('sequence');
    }
    elsif ($type eq 'sync') {
        remove_sync();
    }
    elsif ($type eq 'dbgroup' or $type eq 'dbg') {
        remove_dbgroup();
    }
    else {
        warn "Cannot remove: unknown type\n";
        exit 1;
    }
    exit 0;

} ## end of remove_item


sub remove_customcode {

    ## Usage: remove customcode name [name2 name3 ...]

    my $usage = usage('remove_customcode');

    if (!@nouns) {
        warn "$usage\n";
        exit 1;
    }

    ## Make sure all named codes exist
    my $code = $global{cc};
    for my $name (@nouns) {
        if (! exists $code->{$name}) {
            die qq{No such code: $name\n};
        }
    }

    $SQL = 'DELETE FROM bucardo.customcode WHERE name = ?';
    $sth = $dbh->prepare($SQL);

    for my $name (@nouns) {
        eval {
            $sth->execute($name);
        };
        if ($@) {
            die qq{Could not delete customcode "$name"\n$@\n};
        }
    }

    for my $name (@nouns) {
        print qq{Removed customcode "$name"\n};
    }

    $dbh->commit();

    exit 0;


} ## end of remove_customcode







sub remove_sync {

    ## Usage: remove sync name [name2 name3 ...]

    my $usage = usage('remove_sync');

    if (!@nouns) {
        warn "$usage\n";
        exit 1;
    }

    ## Make sure all named syncs exist
    my $s = $global{sync};
    for my $name (@nouns) {
        if (! exists $s->{$name}) {
            die qq{No such sync: $name\n};
        }
    }

    ## Make sure none of the syncs are currently running
    ## XXX Is there anything we can do to check that the sync is active?

    $SQL = 'DELETE FROM bucardo.sync WHERE name = ?';
    $sth = $dbh->prepare($SQL);

    for my $name (@nouns) {
        eval {
            $sth->execute($name);
        };
        if ($@) {
            if ($@ =~ /"goat_db_fk"/) {
                die qq{Cannot delete sync "$name": must remove all tables that reference it first\n};
            }
            die qq{Could not delete sync "$name"\n$@\n};
        }
    }

    for my $name (@nouns) {
        print qq{Removed sync "$name"\n};
        print "Note: table triggers (if any) are not automatically removed!\n";
    }

    $dbh->commit();

    exit 0;

} ## end of remove_sync




sub clog {

    my $msg = shift;
    chomp $msg;

    warn "$msg\n";

    return;

} ## end of clog


sub schema_exists {

    my ($schema) = @_;
    my $SQL = 'SELECT 1 FROM pg_catalog.pg_namespace WHERE nspname = ?';
    my $sth = $dbh->prepare_cached($SQL);
    my $count = $sth->execute($schema);
    $sth->finish();
    return $count < 1 ? 0 : 1;

} ## end of schema_exists


sub relation_exists {

    ## Checks if a relation exists. Returns the oid or 0
    my ($schema,$name) = @_;
    my $SQL = 'SELECT c.oid FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n '.
        'WHERE n.oid=c.relnamespace AND n.nspname = ? AND c.relname = ?';
    my $sth = $dbh->prepare_cached($SQL);
    my $count = $sth->execute($schema,$name);
    if ($count == 1) {
        return $sth->fetchall_arrayref()->[0][0];
    }
    $sth->finish();
    return 0;

} ## end of relation_exists


sub domain_exists {

    ## Checks if a domain exists. Returns 0 or 1
    my ($schema,$name) = @_;
    my $SQL =
          q{SELECT count(*) FROM pg_catalog.pg_type t }
        . q{JOIN pg_namespace n ON (n.oid = t.typnamespace) }
        . q{WHERE t.typtype = 'd' AND n.nspname = ? AND t.typname = ?};
    my $sth = $dbh->prepare_cached($SQL);
    $count = $sth->execute($schema,$name);
    return $sth->fetchall_arrayref()->[0][0];

} ## end of relation_exists


sub config_exists {

    ## Checks if a configuration settings exists. Returns 1 or 0
    my $name = shift;

    my $SQL = 'SELECT 1 FROM bucardo.bucardo_config WHERE setting = ?';
    my $sth = $dbh->prepare_cached($SQL);
    my $count = $sth->execute($name);
    $sth->finish();
    return $count>=1 ? 1 : 0;

} ## end of config_exists


sub constraint_exists {

    my ($schema,$table,$constraint) = @_;
    my $SQL = 'SELECT 1 FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n, pg_catalog.pg_constraint o '.
        'WHERE n.oid=c.relnamespace AND c.oid=o.conrelid AND n.nspname = ? AND c.relname = ? AND o.conname = ?';
    my $sth = $dbh->prepare_cached($SQL);
    my $count = $sth->execute($schema,$table,$constraint);
    $sth->finish();
    return $count < 1 ? 0 : 1;

} ## end of constraint_exists


sub column_exists {

    my ($schema,$table,$column) = @_;
    my $SQL = 'SELECT 1 FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n, '.
        'pg_catalog.pg_attribute a WHERE n.oid=c.relnamespace AND n.nspname = ? AND c.relname = ? '.
        'AND a.attname = ? AND a.attrelid = c.oid';
    my $sth = $dbh->prepare_cached($SQL);
    my $count = $sth->execute($schema,$table,$column);
    $sth->finish();
    return $count < 1 ? 0 : 1;

} ## end of column_exists


sub trigger_exists {

    my $name = shift;
    my $SQL = 'SELECT 1 FROM pg_catalog.pg_trigger WHERE tgname = ?';
    my $sth = $dbh->prepare_cached($SQL);
    my $count = $sth->execute($name);
    $sth->finish();
    return $count < 1 ? 0 : 1;

} ## end of trigger_exists


sub function_exists {

    my ($schema,$name,$args) = @_;
    $name = lc $name;
    $SQL = 'SELECT md5(prosrc) FROM pg_proc p, pg_language l '.
        'WHERE p.prolang = l.oid AND proname = ? AND oidvectortypes(proargtypes) = ?';
    $sth = $dbh->prepare($SQL);
    $count = $sth->execute($name,$args);
    if ($count eq '0E0') {
        $sth->finish();
        return '';
    }
    return $sth->fetchall_arrayref()->[0][0];

} ## end of function_exists


sub column_default {

    my ($schema,$table,$column) = @_;
    my $SQL = 'SELECT pg_get_expr(adbin,adrelid) FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n, '.
        'pg_catalog.pg_attribute a, pg_attrdef d '.
        'WHERE n.oid=c.relnamespace AND n.nspname = ? AND c.relname = ? '.
        'AND a.attname = ? AND a.attrelid = c.oid AND d.adnum = a.attnum AND d.adrelid = a.attrelid';
    my $sth = $dbh->prepare_cached($SQL);
    my $count = $sth->execute($schema,$table,$column);
    if ($count eq '0E0') {
        $sth->finish();
        return '';
    }
    return $sth->fetchall_arrayref()->[0][0];

} ## end of column_default


sub column_value {

    my ($schema,$table,$column,$where) = @_;
    my $SQL = "SELECT $column FROM $schema.$table WHERE $where";
    return $dbh->selectall_arrayref($SQL)->[0][0];

} ## end of column_value


sub column_type {

    my ($schema,$table,$column) = @_;
    my $SQL = 'SELECT  pg_catalog.format_type(a.atttypid, a.atttypmod) '.
        'FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n, '.
        'pg_catalog.pg_attribute a '.
        'WHERE n.oid=c.relnamespace AND n.nspname = ? AND c.relname = ? '.
        'AND a.attname = ? AND a.attrelid = c.oid';
    my $sth = $dbh->prepare_cached($SQL);
    my $count = $sth->execute($schema,$table,$column);
    if ($count eq '0E0') {
        $sth->finish();
        return '';
    }
    return $sth->fetchall_arrayref()->[0][0];

} ## end of column_type


sub constraint_definition {

    my $name = shift;

    my $SQL = qq{SELECT pg_get_constraintdef(oid) FROM pg_constraint WHERE conname = '$name'};
    my $def = $dbh->selectall_arrayref($SQL)->[0][0];

    return '' if ! defined $def;

    $def =~ s/\((\(.+\))\)/$1/;
    $def =~ s/\"?(\w+)\"? = ANY \(ARRAY\[(.+)\]\)/$1 IN ($2)/;
    $def =~ s/<> ALL \(ARRAY\[(.+)\]\)/NOT IN ($1)/;
    $def =~ s/::text//g;
    $def =~ s/(\w+) ~ '/$1 ~ E'/g;
    $def =~ s/CHECK \(\((\w+)\) <>/CHECK ($1 <>/;

    return $def;

} ## end of constraint_definition


sub table_comment {

    my ($schema,$relation) = @_;

    my $SQL = q{SELECT description FROM pg_description WHERE objoid = (}
        . q{ SELECT c.oid FROM pg_class c JOIN pg_namespace n ON (n.oid = c.relnamespace)}
        . q{ WHERE n.nspname = ? AND c.relname = ?)};

    my $sth = $dbh->prepare($SQL);
    $count = $sth->execute($schema,$relation);
    if ($count < 1) {
        $sth->finish();
        return '';
    }
    return $sth->fetchall_arrayref()->[0][0];

} ## end of table_comment


sub domain_comment {

    my ($schema,$relation) = @_;

    my $SQL = q{SELECT description FROM pg_description WHERE objoid = (}
        . q{ SELECT t.oid FROM pg_type t JOIN pg_namespace n ON (n.oid = t.typnamespace)}
        . q{ WHERE t.typtype = 'd' AND n.nspname = ? AND t.typname = ?)};

    my $sth = $dbh->prepare($SQL);
    $count = $sth->execute($schema,$relation);
    if ($count < 1) {
        $sth->finish();
        return '';
    }
    return $sth->fetchall_arrayref()->[0][0];

} ## end of domain_comment


sub find_bucardo_schema {

    ## Locate the best bucardo.schema file and return a file handle and name for it

    my $fh;

    ## Start by checking the current directory
    my $schema_file = 'bucardo.schema';
    return ($fh, $schema_file) if open $fh, '<', $schema_file;

    ## Try /usr/local/share/bucardo
    $schema_file = '/usr/local/share/bucardo/bucardo.schema';
    return ($fh, $schema_file) if open $fh, '<', $schema_file;

    ## Try /usr/share/bucardo
    $schema_file = '/usr/share/bucardo/bucardo.schema';
    return ($fh, $schema_file) if open $fh, '<', $schema_file;

    die "Could not find the bucardo.schema file!\n";

} ## end of find_bucardo_schema


sub table_definition {

    ## Pull the complete table definition from the bucardo.schema file
    ## Returns an arrayref of sequences, and the textual table def

    my $name = shift;

    my $def = '';

    my ($fh, $schema_file) = find_bucardo_schema();
    my @seq;
    while (<$fh>) {
        if (!$def) {
            if (/^CREATE TABLE $name/) {
                $def .= $_;
            }
        }
        else {
            $def .= $_;
            last if /^\);/;
        }
    }
    close $fh or die qq{Could not close "$schema_file": $!\n};
    while ($def =~ /nextval\('(.+?)'/g) {
        push @seq => $1;
    }

    if (! length($def)) {
        die "Could not find the table definition for $name\n";
    }

    return \@seq, $def;

} ## end of table_definition


sub generate_clause {

    ## Generate a snippet of SQL for a WHERE clause

    my $arg = shift or die;
    return '' if ! $arg->{items} or ! defined $arg->{items}[0];

    my $col = $arg->{col} or die;
    my $items = $arg->{items};
    my ($NOT,$NOTR) = ('','');
    if (exists $arg->{not}) {
        $NOT = 'NOT ';
        $NOTR = '!';
    }
    my $andor = exists $arg->{andor} ? uc($arg->{andor}) : $NOT ? 'AND' : 'OR';

    my (@oneitem,@itemlist);
    for my $name (@{$items}) {
        $name =~ s/^\s*(.+?)\s*$/$1/;
        ## Break into schema and relation
        my $schema = '';
        if ($col eq 'tablename' and $name =~ s/(.+\w)\.(\w.+)/$2/) {
            $schema = $1;
        }

        my $one = 1;
        ## Contains:
        if ($name =~ s/^\*(.+)\*$/$1/) {
            push @oneitem => "$col ${NOTR}~ " . qquote($1);
        }
        ## Starts with:
        elsif ($name =~ s/^\*(.+)/$1/) {
            push @oneitem => "$col ${NOTR}~ " . qquote("$1\$");
        }
        ## Ends with:
        elsif ($name =~ s/(.+)\*$/$1/) {
            push @oneitem => "$col ${NOTR}~ " . qquote("^$1");
        }
        else {
            push @itemlist => qquote($name);
            $one = 0;
        }
        if ($schema) {
            my $col2 = 'schemaname';
            my $old = $one ? pop @oneitem : pop @itemlist;
            if ($schema =~ s/^\*(.+)\*$/$1/) {
                push @oneitem => "($old AND $col2 ${NOTR}~ " . qquote($1) . ')';
            }
            elsif ($schema =~ s/^\*(.+)/$1/) {
                push @oneitem => "($old AND $col2 ${NOTR}~ " . qquote("$1\$") . ')';
            }
            elsif ($schema =~ s/(.+)\*$/$1/) {
                push @oneitem => "($old AND $col2 ${NOTR}~ " . qquote("^$1") . ')';
            }
            else {
                push @oneitem => "($col = $old AND $col2 = " . qquote($schema) . ')';
            }
        }
    }
    if (@itemlist) {
        my $list = sprintf "$col ${NOT}IN (" . (join ',' => @itemlist) . ')';
        push @oneitem => $list;
    }
    my $SQL = join " $andor " => @oneitem;

    return $SQL;

} ## end of generate_clause


sub qquote {

    ## Quick quote
    my $thing = shift;
    $thing =~ s/'/''/g;
    return qq{'$thing'};

} ## end of qquote


sub upgrade {

    ## Make upgrades to an existing Bucardo schema to match the current version

    my $self = shift;

    ## Ensure the bucardo.schema file is available and the correct version
    my ($fh, $schema_file) = find_bucardo_schema();

    my $schema_version = 0;
    while (<$fh>) {
        if (/\-\- Version (\d+\.\d+\.\d+)/) {
            $schema_version = $1;
            last;
        }
    }
    if (! $schema_version) {
        die qq{Could not find version number in the file "$schema_file"!\n};
    }
    if ($schema_version ne $VERSION) {
        die qq{Cannot continue: bucardo is version $VERSION, but $schema_file is version $schema_version\n};
    }

    $dbh->do(q{SET escape_string_warning = 'OFF'});

    my $changes = 0;

    ## Quick sanity to make sure we don't try to cross the 4/5 boundary
    if (!relation_exists('bucardo', 'syncrun')) {
      print "Sorry, but Bucardo version 4 cannot be upgraded to version 5\n";
      print "You will have to recreate your information (dbs, syncs, etc.)\n";
      exit 1;
    }

    ## Make sure the upgrade_log table is in place

    if (!relation_exists('bucardo', 'upgrade_log')) {
        my ($seqlist, $tabledef) = table_definition('bucardo.upgrade_log');
        upgrade_and_log($tabledef,'CREATE TABLE bucardo.upgrade_log');
        $dbh->commit();
    }

    my @old_sequences = (
        'dbgroup_id_seq',
    );

    my @old_configs = (
        'pidfile',
        'upsert_attempts',
    );

    my @old_constraints = (
        ['bucardo', 'goat', 'goat_pkeytype_check'],
        ['bucardo', 'sync', 'sync_replica_allornone'],
        ['bucardo', 'sync', 'sync_disable_triggers_method'],
        ['bucardo', 'sync', 'sync_disable_rules_method'],
    );

    my @old_columns = (
        ['bucardo', 'sync', 'disable_rules'],
        ['bucardo', 'sync', 'disable_triggers'],
    );

    my @old_functions = (
        ['create_child_q', 'text'],
    );

    my @old_indexes = (
        ['bucardo', 'sync', 'sync_source_targetdb'],
        ['bucardo', 'sync', 'sync_source_targetgroup'],
    );

    my @old_views = (
        'goats_in_herd'
    );

    my @new_columns = (
    );

    my @altered_columns = (
        ['bucardo', 'goat', 'rebuild_index', 'BOOL2SMALLINT1'],
        ['bucardo', 'goat', 'schemaname',    'NO DEFAULT'],
        ['bucardo', 'sync', 'rebuild_index', 'BOOL2SMALLINT1'],
    );

    my @row_values = (

        ['bucardo_config','about',q{setting = 'log_showtime'}, 1,
         'Show timestamp in the log output?  0=off  1=seconds since epoch  2=scalar gmtime  3=scalar localtime'],
    );

    my @drop_all_rules = (
    );

    ## Drop all existing rules from a table:
    for my $row (@drop_all_rules) {
        my ($schema,$table) = @$row;
        my $oid = relation_exists($schema,$table);
        if (!$oid) {
            warn "Could not find table $schema.$table to check!\n";
            next;
        }
        $SQL = 'SELECT rulename FROM pg_catalog.pg_rewrite WHERE ev_class = ? ORDER BY rulename';
        $sth = $dbh->prepare($SQL);
        $count = $sth->execute($oid);
        if ($count < 1) {
            $sth->finish();
            next;
        }
        for my $rule (map { $_->[0] } @{$sth->fetchall_arrayref()}) {
            upgrade_and_log(qq{DROP RULE "$rule" ON $schema.$table});
            clog "Dropped rule $rule on table $schema.$table";
            $changes++;
        }
    }

    ## Drop any old views
    for my $name (@old_views) {
        next if !relation_exists('bucardo', $name);
        upgrade_and_log("DROP VIEW $name");
        clog "Dropped view $name";
        $changes++;
    }

    ## Drop any old sequences
    for my $sequence (@old_sequences) {
        next if !relation_exists('bucardo', $sequence);
        upgrade_and_log("DROP SEQUENCE bucardo.$sequence");
        clog "Dropped sequence: $sequence";
        $changes++;
    }

    ## Drop any old constraints
    for my $con (@old_constraints) {
        my ($schema, $table, $constraint) = @$con;
        next if !constraint_exists($schema, $table, $constraint);
        upgrade_and_log(qq{ALTER TABLE $schema.$table DROP CONSTRAINT "$constraint"});
        clog "Dropped constraint $constraint ON $schema.$table";
        $changes++;
    }

    ## Parse the bucardo.schema file and verify the following types of objects exist:
    ## Functions, triggers, constraints, sequences, indexes, comments, and domains
    my (@flist, @tlist, @ilist, @clist, @clist2, @slist, @tablelist, @comlist, @domlist, @collist);
    my ($fname,$args,$fbody) = ('','','');
    my ($tname,$tbody) = ('','');
    my ($tablename,$tablebody) = ('','');
    my ($altername,$alterbody,$alterstat) = ('','','');
    seek $fh, 0, 0;
    while (<$fh>) {
        if ($fbody) {
            if (/^(\$bc\$;)/) {
                $fbody .= $1;
                push @flist, [$fname, $args, $fbody];
                $fbody = $fname = $args = '';
            }
            else {
                $fbody .= $_;
            }
            next;
        }
        if ($tbody) {
            $tbody .= $_;
            if (/;/) {
                push @tlist, [$tname, $tbody];
                $tbody = $tname = '';
            }
            next;
        }
        if ($tablebody) {
            $tablebody .= $_;
            if (/^\s*CONSTRAINT\s+(\w+)\s+(.+?)\s*$/) {
                my ($cname,$def) = ($1,$2);
                $def =~ s/,$//;
                $def =~ s/\bbucardo\.//;
                push @clist2, [$tablename, $cname, $def];
            }
            elsif (/^\s+([a-z_]+)\s+([A-Z]+)\s*(NOT)? NULL/) {
                my ($colname,$coltype,$isnull) = ($1, $2, $3 ? 1 : 0);
                push @collist, ['bucardo', $tablename, $colname, $_];
            }
            elsif (/;/) {
                push @tablelist, [$tablename, $tablebody];
                $tablebody = $tablename = '';
            }
            else {
                die qq{Could not parse table definition: invalid column at line $. ($_)\n};
            }
            next;
        }
        if ($altername) {
            $alterbody =~ s/\s+$//;
            $alterbody ? s/^\s+/ / : s/^\s+//;
            s/\s+$/ /;
            $alterbody .= $_;
            $alterstat .= $_;
            if ($alterbody =~ s/;\s*$//) {
                push @clist, [$altername->[0], $altername->[1], $alterbody, $alterstat];
                $alterbody = $altername = $alterstat = '';
            }
            next;
        }
        if (/^CREATE (?:OR REPLACE )?FUNCTION\s+bucardo\.(.+?\))/) {
            $fname = $1;
            $fbody .= $_;
            $fname =~ s/\((.*)\)// or die "No args found for function: $_\n";
            $args = $1;
            $args =~ s/,(\S)/, $1/g;
            next;
        }
        if (/^CREATE TRIGGER (\S+)/) {
            $tname = $1;
            $tbody .= $_;
            next;
        }
        if (/^CREATE TABLE bucardo\.(\w+)/) {
            $tablename = $1;
            $tablebody .= $_;
            next;
        }
        if (/^CREATE (UNIQUE )?INDEX (\S+)/) {
            push @ilist, [$1, $2, $_];
            next;
        }
        if (/^ALTER TABLE bucardo\.(\S+)\s+ADD CONSTRAINT\s*(\S+)\s*(\S*.*)/) {
            $altername = [$1,$2];
            $alterbody = $3 || '';
            $alterstat = $_;
            next;
        }
        if (/^CREATE SEQUENCE bucardo\.(\w+)/) {
            push @slist, [$1, $_];
            next;
        }
        if (/^COMMENT ON (\w+) (\w+)\.(\w+) IS \$\$(.+)\$\$/) {
            push @comlist, [lc $1, $2, $3, $4, $_];
            next;
        }
        if (/^CREATE DOMAIN bucardo\.(\w+) (.+)/) {
            push @domlist, [$1, $2];
            next;
        }
    }

    ## Add any new domains, verify existing ones
    for my $row (@domlist) {
        my ($name,$def) = @$row;
        next if domain_exists('bucardo', $name);
        upgrade_and_log("CREATE DOMAIN bucardo.$name $def");
        clog("Created domain: $name");
        $changes++;
    }

    ## Check for any added tables
    for my $row (@tablelist) {
        my ($name,$body) = @$row;
        next if relation_exists('bucardo', $name);
        upgrade_and_log($body);
        clog "Created table $name";
        $changes++;
    }

    ## Add new columns as needed from the schema
    for my $row (@collist) {
        my ($schema,$table,$column,$def) = @$row;
        next if column_exists($schema, $table, $column);
        $def =~ s/\-\-.+$//;
        $def =~ s/,\s*$//;
        $def =~ s/\s+/ /g;
        upgrade_and_log("ALTER TABLE $schema.$table ADD COLUMN $def");
        clog "Created column: $schema.$table.$column";
        $changes++;
    }

    ## Add specific new columns as needed
    for my $row (@new_columns) {
        my ($schema,$table,$column,$def) = @$row;
        next if column_exists($schema, $table, $column);
        $def =~ s/\s+/ /g;
        upgrade_and_log("ALTER TABLE $schema.$table ADD COLUMN $def");
        clog "Created column: $schema.$table.$column";
        $changes++;
    }

    ## Change any altered columns
    for my $row (@altered_columns) {
        my ($schema,$table,$column,$change) = @$row;
        next if ! column_exists($schema, $table, $column);
        if ($change eq 'NO DEFAULT') {
            my $def = column_default($schema, $table, $column);
            next if !$def;
            upgrade_and_log("ALTER TABLE $schema.$table ALTER COLUMN $column DROP DEFAULT");
            clog "Removed DEFAULT ($def) from $schema.$table.$column";
            $changes++;
        }
        elsif ($change =~ /^RENAME\s+(\w+)/) {
            my $newname = $1;
            upgrade_and_log("ALTER TABLE $schema.$table RENAME COLUMN $column TO $newname");
            clog("Renamed $schema.$table.$column to $newname");
            $changes++;
        }
        elsif ($change =~ /^DEFAULT\s+(.+)/) {
            my $newname = $1;
            my $oldname = column_default($schema, $table, $column);
            next if $newname eq $oldname;
            upgrade_and_log("ALTER TABLE $schema.$table ALTER COLUMN $column SET DEFAULT $newname");
            clog("Changed DEFAULT on $schema.$table.$column to $newname");
            $changes++;
        }
        elsif ($change =~ /BOOL2SMALLINT(\d)/) {
            my $defval = $1;
            my $oldtype = column_type($schema, $table, $column);
            next if $oldtype eq 'smallint';
            upgrade_and_log("ALTER TABLE $schema.$table ALTER COLUMN $column DROP DEFAULT");
            upgrade_and_log("ALTER TABLE $schema.$table ALTER COLUMN $column TYPE smallint "
                            . "USING CASE WHEN $column IS NULL OR $column IS FALSE THEN 0 ELSE $defval END");
            upgrade_and_log("ALTER TABLE $schema.$table ALTER COLUMN $column SET DEFAULT 0");
            clog("Changed type of $schema.$table.$column to smallint");
            $changes++;
        }
        else {
            die qq{Do not know how to handle altered column spec of "$change"};
        }
    }

    ## Special cases
    if (! column_exists('bucardo', 'goat', 'source_makedelta')) {
        #upgrade_and_log(q{ALTER TABLE bucardo.goat ADD COLUMN source_makedelta ONOFF NOT NULL DEFAULT 'inherits'});
        #upgrade_and_log(q{ALTER TABLE bucardo.goat ADD COLUMN target_makedelta ONOFF NOT NULL DEFAULT 'inherits'});
        if (column_exists('bucardo', 'goat', 'makedelta')) {
        #    upgrade_and_log(q{UPDATE goat SET source_makedelta='on', target_makedelta='on' WHERE makedelta IS TRUE});
        #    upgrade_and_log(q{UPDATE goat SET source_makedelta='off', target_makedelta='off' WHERE makedelta IS FALSE});
        #    upgrade_and_log('ALTER TABLE bucardo.goat DROP COLUMN makedelta');
        }
        #clog('Added columns goat.source_makedelta and goat.target_makedelta');
        #$changes++;
    }
    if (! column_exists('bucardo', 'sync', 'source_makedelta')) {
        #upgrade_and_log(q{ALTER TABLE bucardo.sync ADD COLUMN source_makedelta ONOFF NOT NULL DEFAULT 'inherits'});
        #upgrade_and_log(q{ALTER TABLE bucardo.sync ADD COLUMN target_makedelta ONOFF NOT NULL DEFAULT 'inherits'});
        if (column_exists('bucardo', 'sync', 'makedelta')) {
         #   upgrade_and_log(q{UPDATE sync SET source_makedelta='on', target_makedelta='on' WHERE makedelta IS TRUE});
         #   upgrade_and_log(q{UPDATE sync SET source_makedelta='off', target_makedelta='off' WHERE makedelta IS FALSE});
         #   upgrade_and_log('ALTER TABLE bucardo.sync DROP COLUMN makedelta');
        }
        #clog('Added columns sync.source_makedelta and sync.target_makedelta');
        #$changes++;
    }

    ## Drop any old columns
    for my $row (@old_columns) {
        my ($schema,$table,$column) = @$row;
        next if !column_exists($schema, $table, $column);
        upgrade_and_log("ALTER TABLE $schema.$table DROP COLUMN $column");
        clog "Dropped column: $schema.$table.$column";
        $changes++;
    }

    ## Drop any old indexes
    for my $row (@old_indexes) {
        my ($schema,$table,$name) = @$row;
        next if !relation_exists($schema, $name);
        upgrade_and_log("DROP INDEX $name");
        clog "Dropped index $name";
        $changes++;
    }

    ## Drop any old functions
    for my $row (@old_functions) {
        my ($name, $largs) = @$row;
        next if ! function_exists('bucardo', $name, $largs);
        clog "Dropped function $name($largs)";
        upgrade_and_log(qq{DROP FUNCTION bucardo."$name"($largs)});
        $changes++;
    }

    ## Drop any old config items
    for my $name (@old_configs) {
        next if ! config_exists($name);
        clog "Removed old bucardo_config setting: $name";
        upgrade_and_log(qq{DELETE FROM bucardo.bucardo_config WHERE setting = '$name'});
        $changes++;
    }

    ## Check for any new config items
    $SQL = 'SELECT value FROM bucardo.bucardo_config WHERE lower(setting) = ?';
    my $cfgsth = $dbh->prepare($SQL);
    $SQL = 'INSERT INTO bucardo.bucardo_config(setting,value,about) VALUES (?,?,?)';
    my $newcfg = $dbh->prepare($SQL);
    my %config;
    my $inside = 0;
    seek $fh, 0, 0;
    while (<$fh>) {
        if (!$inside) {
            if (/^WITH DELIMITER/) {
                $inside = 1;
            }
            next;
        }
        if (/^\\/) {
            $inside = 0;
            next;
        }
        ## Scoop
        my ($setting,$value,$about) = split /\|/ => $_;
        $config{$setting} = [$value,$about];
        $count = $cfgsth->execute($setting);
        $cfgsth->finish();
        if ($count eq '0E0') {
            clog "Added new bucardo_config setting: $setting";
            $changes++;
            $newcfg->execute($setting,$value,$about);
        }
    }
    close $fh or die qq{Could not close file "$file": $!\n};

    ## Apply any specific row changes
    for my $row (@row_values) {
        my ($table,$column,$where,$force,$value) = @$row;
        my $val = column_value('bucardo',$table,$column,$where);
        if (!defined $val) {
            die "Failed to find $table.$column where $where!\n";
        }
        next if $val eq $value;
        $SQL = sprintf "UPDATE bucardo.$table SET $column=%s WHERE $where",
            $dbh->quote($value);
        upgrade_and_log($SQL);
        clog "New value set for bucardo.$table.$column WHERE $where";
        $changes++;
    }


    $SQL = 'SELECT pg_catalog.md5(?)';
    my $md5sth = $dbh->prepare($SQL);
    for my $row (@flist) {
        my ($name,$arg,$body) = @$row;
        next if $name =~ /plperlu_test/;
        my $oldbody = function_exists('bucardo',$name,$arg);
        if (!$oldbody) {
            upgrade_and_log($body,"CREATE FUNCTION $name($arg)");
            clog "Added function $name($arg)";
            $changes++;
            next;
        }
        my $realbody = $body;
        $realbody =~ s/.*?\$bc\$(.+)\$bc\$;/$1/sm;
        $md5sth->execute($realbody);
        my $newbody = $md5sth->fetchall_arrayref()->[0][0];
        next if $oldbody eq $newbody;
        $body =~ s/^CREATE FUNCTION/CREATE OR REPLACE FUNCTION/;
        (my $short = $body) =~ s/^(.+?)\n.*/$1/s;
        $dbh->do('SAVEPOINT bucardo_upgrade');
        eval { upgrade_and_log($body,$short); };
        if ($@) {
            $dbh->do('ROLLBACK TO bucardo_upgrade');
            (my $dropbody = $short) =~ s/CREATE OR REPLACE/DROP/;
            $dropbody .= ' CASCADE';
            upgrade_and_log($dropbody);
            upgrade_and_log($body,$short);
        }
        else {
            $dbh->do('RELEASE bucardo_upgrade');
        }
        clog "Updated function: $name($arg)";
        $changes++;
    }

    ## Check for any added sequences
    for my $row (@slist) {
        my ($sname,$body) = @$row;
        next if relation_exists('bucardo', $sname);
        upgrade_and_log($body);
        clog "Created sequence $sname";
        $changes++;
    }

    ## Check for any added triggers
    for my $row (@tlist) {
        my ($name,$body) = @$row;
        next if trigger_exists($name);
        upgrade_and_log($body);
        clog "Created trigger $name";
        $changes++;
    }

    ## Check for any added indexes
    for my $row (@ilist) {
        my ($uniq,$name,$body) = @$row;
        next if relation_exists('bucardo',$name);
        upgrade_and_log($body);
        clog "Created index $name";
        $changes++;
    }

    ## Check for any added constraints
    for my $row (@clist) {
        my ($tcname,$cname,$cdef,$body) = @$row;
        if (! constraint_exists('bucardo', $tcname, $cname)) {
            upgrade_and_log($body);
            clog "Created constraint $cname on $tcname";
            $changes++;
            next;
        }

        ## Clean up the constraint to make it match what comes back from the database:
        $cdef =~ s/;$//;
        $cdef =~ s/','/', '/g;
        if ($cdef =~ s/([^)]) (OR|AND) (\w)/$1) $2 ($3/g) {
            $cdef =~ s/CHECK (.+)/CHECK ($1)/;
        }
        my $condef = constraint_definition($cname);
        if ($condef ne $cdef) {
        warn "cdef from bucardo.schema: $cdef\n";
        warn "con  from live  database: $condef\n";
            upgrade_and_log("ALTER TABLE $tcname DROP CONSTRAINT $cname");
            upgrade_and_log("ALTER TABLE $tcname ADD CONSTRAINT $cname $cdef");
            clog "Altered constraint $cname on $tcname";
            $changes++;
        }
    }

    ## Check that any bare constraints (e.g. foreign keys) are unchanged
    for my $row (@clist2) {
        my ($tcname,$cname,$cdef) = @$row;
        my $condef = constraint_definition($cname);
        next if ! $condef or $condef eq $cdef;
        if ($condef and $condef ne $cdef) {
            upgrade_and_log("ALTER TABLE $tcname DROP CONSTRAINT $cname");
        }
        upgrade_and_log("ALTER TABLE $tcname ADD CONSTRAINT $cname $cdef");
        my $action = $condef ? 'Altered' : 'Added';
        clog "$action constraint $cname on $tcname";
        $changes++;
    }

    ## Check that object comments exist and match
    for my $row (@comlist) {
        my ($type,$schema,$relation,$comment,$full) = @$row;
        my $current_comment =
            $type eq 'table' ? table_comment($schema,$relation)
            : $type eq 'domain' ? domain_comment($schema,$relation)
            : 'Unkonwn type';
        if ($current_comment ne $comment) {
            upgrade_and_log($full);
            clog (length $current_comment
                ? "Changed comment on $type $schema.$relation"
                : "Added comment for $type $schema.$relation");
            $changes++;
        }
    }

    ## The freezer.q_staging table is no longer needed, but we must empty it before dropping
    if (relation_exists('freezer','q_staging')) {
        upgrade_and_log('INSERT INTO freezer.master_q SELECT * FROM freezer.q_staging');
        upgrade_and_log('DROP TABLE freezer.q_staging');
        clog 'Dropped deprecated table freezer.q_staging';
        $changes++;
    }

    ## Make sure bucardo_config has the new schema version
    $count = $cfgsth->execute('bucardo_current_version');
    if ($count eq '0E0') {
        $cfgsth->finish();
        warn "Weird: could not find bucardo_current_version in the bucardo_config table!\n";
    }
    else {
        my $curval = $cfgsth->fetchall_arrayref()->[0][0];
        if ($curval ne $schema_version) {
            $SQL = 'UPDATE bucardo.bucardo_config SET value = ? WHERE setting = ?';
            my $updatecfg = $dbh->prepare($SQL);
            $updatecfg->execute($schema_version, 'bucardo_current_version');
            clog "Set bucardo_config.bucardo_current_version to $schema_version";
            $changes++;
        }
    }

    ## Run the magic updater
    $SQL = 'SELECT bucardo.magic_update()';
    $sth = $dbh->prepare($SQL);
    $sth->execute();
    my $msg = $sth->fetchall_arrayref()->[0][0];
    if (length $msg) {
        clog $msg;
        $changes++;
    }

    if ($changes) {
        printf "Okay to commit $changes %s? ", $changes==1 ? 'change' : 'changes';
        #exit if <STDIN> !~ /Y/i;
        $dbh->commit();
        print "Changes have been commited\n";
    }
    else {
        print "No schema changes were needed\n";
        exit 1;
    }

    print "Don't forget to run '$progname validate all' as well: see the UPGRADE file for details\n";

    exit 1;

} ## end of upgrade


sub upgrade_and_log {

    my $action = shift;
    my $short = shift || $action;

    eval {
        $dbh->do($action);
    };
    if ($@) {
        my $line = (caller)[2];
        die "From line $line, action $action\n$@\n";
    }

    $SQL = 'INSERT INTO bucardo.upgrade_log(action,version,summary) VALUES (?,?,?)';
    eval {
        $sth = $dbh->prepare($SQL);
        $sth->execute($action,$VERSION,$short);
    };
    if ($@) {
        my $line = (caller)[2];
        die "From line $line, insert to upgrade_log failed\n$@\n";
    }

    return;

} ## end of upgrade_and_log


sub usage {

    my $name = shift or die;

    ## no critic (RequireInterpolationOfMetachars)
    if ('add' eq $name) {
        return qq{Usage: add <type> <name> [options]
Adds an item to the internal Bucardo database.
The type is one of: code, db, dbgroup, herd, sync, table, or sequence
For more information, run: $progname help add <type>};
    }
    if ('add_customcode' eq $name) {
        return q{Usage: add customcode <name> <whenrun=value> <src_code=filename> [optional information]};
    }
    if ('add_database' eq $name) {
        return q{Usage: add db <name> [optional information]
Adds a database

Optional information:
 type=type of database
 name=internal_name (defaults to the database name)
 host=hostname      (defaults to none: Unix socket)
 user=username      (defaults to 'bucardo')
 port=#             (defaults to system default, usually 5432)
 group=groupname    (database group, will be created if needed)
 conn=string        (extra connection parameters, e.g. "sslmode=require")
 status=status      (active or inactive, defaults to 'active')
 sourcelimit=#      (maximum concurrent reads from this database. Default is 0 (no limit))
 targetlimit=#      (maximum concurrent writes from this database. Default is 0 (no limit))
 ssp=#              (if server-side prepares are used, defaults to 1 (on))
 makedelta=onoff    (whether this database needs makedelta magic)
 addalltables       (automatically adds all tables in the database)
 addallsequences    (automatically adds all sequences in the database)};
    }
    if ('add_dbgroup' eq $name) {
        return q{Usage: add dbgroup <name> [database1 database2 ...]
Adds a database group, and optionally which databases are members of it.
This can also be used to assign databases to an existing group.};
    }
    if ('add_herd' eq $name) {
        return q{Usage: add herd <name> [table1 table2 ...]
Adds a herd, and optionally which tables are members of it.
This can also be used to assign tables to an existing herd.};
    }
    if ('add_sync' eq $name) {
        return q{Usage: add sync <name> herd=x dbs=dbgroup [options]
Adds a sync. Required args:
  herd=name          (the herd containing the tables and sequences to be replicated)
  dbs=name           (the database group, or a comma-separated list of databases)

Optional information:
  status=x           (One of 'active' or 'inactive', defaults to 'active')
  rebuild_index      (whether to rebuild indexes after every sync, defaults to 0 (off))
  lifetime=number    (how long a kid can live before being reaped, defaults to null (no limit))
  maxkicks=number    (how many kicks a kid can process before being reaped, defaults to 0 (no limit))
  onetimecopy=number (for pushdelta syncs only, controls whether we switch to a fullcopy mode for one run,
                      0=off, 1=always full copy, 2=only copy tables which are empty on the target)
  tables=list        (list of tables to add to this new sync,
                      will create a herd with the same name as the sync)};
    }
    if ('add_sequence' eq $name) {
        return q{Usage: add sequence <name> [name2 name3 ...]
Adds one or more sequences to the internal Bucardo database.};
    }
    if ('add_table' eq $name) {
        return q{Usage: add table <name> [name2 name3 ...]
Adds one or more tables to the internal Bucardo database.
Use "table" to find all matching tables, or be specific with "schema.table"
Can use wildcards, e.g. "foobar%"
Use "add table all" to add in all tables};
    }
    if ('config' eq $name) {
        return q{Usage: config show [all | name]
Usage: config set foo=bar [foo2=bar2]
Displays or sets settings from the bucardo_config table.
Using 'show' will display all settings or a subset based on the given name.
Using 'set' will change one or more settings.};
    }
    if ('inspect' eq $name) {
        return q{Usage: inspect <type> <name>
Inspects an object to see if it has dependency issues.
The only supported type is currently 'table'.};
    }
    if ('inspect_herd' eq $name) {
        return q{Usage: inspect herd <name>
Inspects a herd to see if it has dependency issues.};
    }
    if ('inspect_sync' eq $name) {
        return q{Usage: inspect sync <name>
Inspects a sync to see if it has dependency issues.};
    }
    if ('inspect_table' eq $name) {
        return q{Usage: inspect table <name>
Inspects a table to see if it has dependency issues.};
    }
    if ('kick' eq $name) {
        return q{Usage: kick <name> [# of seconds] [name2 name3...] [--notimer]
Kicks one or more named syncs.
If a number is given, that is how long to wait for the sync to signal that it is finished.
If the number 0 is given, we wait as long as it takes.
By default a graphical timer is given: this can be turned off with the --notimer option.};
    }
    if ('list' eq $name) {
        return q{Usage: list <type> [options]
Shows information about items in the internal Bucardo database.
The type is one of: code, db, dbgroup, table, sequence, herd, sync, customcode
For more information, run: $progname help list <type>};
    }
    if ('list_customcode' eq $name) {
        return q{Usage: list customcode name [options]
Lists information about each customcode.
If ''verbose' is added, the 'About' for each code is shown.
If '--verbose --verbose' is added, the internal database columns for the 'customcode' table are shown.};
    }
    if ('list_databases' eq $name) {
        return q{Usage: list db [name] [--verbose] [--verbose]
Lists information about each database Bucardo knows about.

Without a name, all databases are listed.
The name can have wildcards with a '*' at the start and/or end.
If '--verbose' is added, information is shown about which groups and syncs are involved.
If a second '--verbose' is added, the internal database columns for the 'db' table are shown.};
    }
    if ('list_dbgroups' eq $name) {
        return q{Usage: list dbgroup [name] [--verbose --verbose]
Lists database groups, and which databases (if any) are members.

Without a name, all database groups are listed.
The name can have wildcards with a '*' at the start and/or end.
If '--verbose --verbose' is added, the internal database columns for the 'dbgroup' table are shown.};
    }
    if ('list_herds' eq $name) {
        return q{Usage: list herd [name] [--verbose --verbose]
Lists herds, and which tables (if any) are members.

Without a name, all herds are listed.
The name can have wildcards with a '*' at the start and/or end.
If '--verbose --verbose' is added, the internal database columns for the 'herd' table are shown.};
    }
    if ('list_syncs' eq $name) {
        return q{Usage: list sync [name] [--verbose --verbose]
Lists syncs

Without a name, all syncs are listed.
The name can have wildcards with a '*' at the start and/or end.
If '--verbose --verbose' is added, the internal database columns for the 'sync' table are shown.};
    }
    if ('list_sequences' eq $name) {
        return q{Usage: list sequence [name] [--verbose --verbose]
Lists sequences

Without a name, all sequences are listed.
The name can have wildcards with a '*' at the start and/or end.
If '--verbose --verbose' is added, the internal database columns for the 'goat' table are shown.};
    }
    if ('list_tables' eq $name) {
        return q{Usage: list table [name] [--verbose --verbose]
Lists tables

Without a name, all tables are listed.
The name can have wildcards with a '*' at the start and/or end.
If '--verbose --verbose' is added, the internal database columns for the 'goat' table are shown.};
    }
    if ('message' eq $name) {
        return q{Usage: message "text"
Asks a running Bucardo daemon to insert the given text into the Bucardo log files.};
    }
    if ('ping' eq $name) {
        return q{Usage: ping [# of seconds]
Sends a ping notice to the main Bucardo process (MCP) to see if it will respond.
By default, it will wait 15 seconds for a response.
If a number is given, it will wait that number of seconds instead.
Returns a Nagios like message starting with "OK" or "CRITICAL" for success or failure.\n};
    }
    if ('reload' eq $name) {
        return q{Usage: reload sync [sync2 sync3 ...]
Reloads one or more syncs.
This sends a message to Bucardo to stop the named syncs, reload their
information from the database, and start them up again.
Useful if you have changed a setting for an active syncs and need
to put the change in place right away.};
    }
    if ('reload_config' eq $name) {
        return q{Usage: reload_config
Instructs the Bucardo daemon to reload its configuration file and restart.};
    }
    if ('remove' eq $name or 'delete' eq $name) {
        return qq{Usage: remove <type> <name> [options]
Removes an item from the internal Bucardo database.
The type is one of: code, db, dbgroup, table, sequence, herd, sync
For more information, run: $progname help remove <type>};
    }
    if ('remove_customcode' eq $name) {
        return qq{Usage: $verb customcode <name> [name2 name3 ...]
Removes one or more customcodes.};
    }
if ('remove_database' eq $name) {
        return qq{Usage: $verb db <name> [name2 name3 ...]
Removes one or more databases.};
    }
    if ('remove_dbgroup' eq $name) {
        return qq{Usage: $verb dbgroup <name> [name2 name3 ...]
Removes one or more database groups.};
    }
    if ('remove_herd' eq $name) {
        return qq{Usage: $verb herd <name> [name2 name3 ...]
Removes one or more herds.};
    }
    if ('remove_sync' eq $name) {
        return qq{Usage: $verb sync <name> [name2 name3 ...]
Removes one or more syncs.};
    }
    if ('remove_sequence' eq $name) {
        return qq{Usage: $verb sequence <name> [name2 name3 ...]
Removes one or more sequences.};
    }
    if ('remove_table' eq $name) {
        return qq{Usage: $verb table <name> [name2 name3 ...]
Removes one or more tables.};
    }
    if ('restart' eq $name) {
        return q{Usage: restart ["reason"]
Restarts Bucardo by stopping, then starting it up again.
An optional reason can be given.};
    }
    if ('start' eq $name) {
        return q{Usage: start ["reason"]
Starts Bucardo.
An optional reason can be given.};
    }
    if ('status' eq $name) {
        return q{Usage: status [sync1 sync2]
Displays information about the status of syncs.
With no arguments, shows a summary of all syncs.
If one or more named syncs are given, detailed information
about each sync is given.}
    }
    if ('stop' eq $name) {
        return q{Usage: stop ["reason"]
Stops Bucardo and all of its child processes.
An optional reason can be given.
Active children will not stop until they have finished their current task.};
    }
    if ('update' eq $name) {
        return q{Usage: update <type> <name> col1=val [col2=val2 col3=val3 ...]
Updates an item from the internal Bucardo database.
The type is one of: code, db, dbgroup, table, sequence, herd, sync.};
    }
    if ('update_database' eq $name) {
        return q{Usage: update database <name> col1=val [col2=val2 col3=val3 ...]
Updates a database
    };
    }
    if ('upgrade' eq $name) {
        return q{Usage: upgrade
Upgrades an existing Bucardo database to the current version.};
    }
    if ('validate' eq $name) {
        return q{Usage: validate [all] [sync1 sync2]
Validates one or more named syncs.
Use 'all' to validate all known syncs at once};
    }

    ## use critic

    return '';

} ## end of usage


sub get_dbs {

    ## Grab information about all entries in the 'db' table

    $SQL = 'SELECT * FROM bucardo.db ORDER BY name';
    $sth = $dbh->prepare($SQL);
    $sth->execute();
    my $info = $sth->fetchall_hashref('name');
    return $info;

} ## end of get_dbs


sub connect_database {

    ## Connect to a datbase and return a dbh

    my $dbh2;

    my $opt = shift || {};

    ## If given just a name, transform to a hash
    if (! ref $opt) {
        $opt = { name => $opt };
    }

    if (exists $opt->{name}) {
        $SQL = qq{SELECT bucardo.db_getconn('$opt->{name}')};
        my $conn = $dbh->selectall_arrayref($SQL)->[0][0];
        my ($type,$dsn,$user,$pass) = split /\n/ => $conn;

        if ($type ne 'postgres') {
            return "Cannot return a handle for database type $type";
        }

        eval {
            $dbh2 = DBI->connect_cached($dsn, $user, $pass, {AutoCommit=>0,RaiseError=>1,PrintError=>0});
        };
        if ($@) {
            ## The bucardo user may not exist yet.
            if ($user eq 'bucardo' and $@ =~ /FATAL/ and $@ =~ /bucardo/) {
                $user = 'postgres';
                $dbh2 = DBI->connect_cached($dsn, $user, $pass, {AutoCommit=>0,RaiseError=>1,PrintError=>0});
                $dbh2->do('CREATE USER bucardo SUPERUSER');
                $dbh2->commit();
                $user = 'bucardo';
                $dbh2 = DBI->connect_cached($dsn, $user, $pass, {AutoCommit=>0,RaiseError=>1,PrintError=>0});
            }
        }
    }

    return $dbh2;

} ## end of connect_database


sub config {

    ## View or change a value inside the bucardo_config table

    my $setusage = "Usage: $progname set setting=value [setting=value ...]\n";

    ## Allow for old syntax
    if ($verb eq 'config') {
        @nouns or die "Usage: $progname config [set|show]\n";
        $verb = shift @nouns;
    }

    if (!@nouns) {
        $verb eq 'set' and die $setusage;
        die "Usage: $progname show <all|setting1> [settting2 ...]\n";
    }

    $SQL = 'SELECT * FROM bucardo.bucardo_config';
    $sth = $dbh->prepare($SQL);
    $sth->execute();
    my $config = $sth->fetchall_hashref('setting');
    if ($verb eq 'show') {
        my $all = $nouns[0] =~ /\ball\b/i ? 1 : 0;
        my $maxsize = 3;
        for my $s (keys %$config) {
            next if ! $all and ! grep { $s =~ /$_/i } @nouns;
            $maxsize = length $s if length $s > $maxsize;
        }
        for my $s (sort keys %$config) {
            next if ! $all and ! grep { $s =~ /$_/i } @nouns;
            printf "%-*s = %s\n", $maxsize, $s, $config->{$s}{value};
        }
        exit 1;
    }

    $SQL = 'UPDATE bucardo.bucardo_config SET value = ? WHERE setting = ?';
    $sth = $dbh->prepare($SQL);

    for my $noun (@nouns) {
        $noun =~ /(\w+)=(.+)/ or die $setusage;
        my ($setting,$val) = (lc $1,$2);

        if (! exists $config->{$setting}) {
            die qq{Unknown setting "$setting"\n};
        }

        ## Sanity checks
        if ($setting eq 'log_level') {
            if ($val !~ /^(?:terse|normal|verbose|debug)$/oi) {
                die "Invalid log_level, must be terse, normal, verbose, or debug\n";
            }
        }
        if ($setting eq 'default_standard_conflict') {
            if ($val !~ /^(?:source|target|skip|random|latest|none)$/oi) {
                ## FIXME
                #die "Invalid default_standard_conflict, must be none, source, target, skip, random, or latest\n";
            }
            if ($val =~ /none/i) {
                $val = '';
            }
        }

        $sth->execute($val,$setting);
        print qq{Set "$setting" to "$val"\n};

    }

    $dbh->commit();

    exit 0;

} ## end of config


sub message {

    ## Add a message to the Bucardo logs, via the bucardo_log_message table
    ## Note: If no MCP processes are listening, the message will hang out until an MCP processes it

    if (! length($nouns)) {
        die qq{Usage: bucardo message "Some message to send to the logs"\n};
    }

    $SQL = 'INSERT INTO bucardo.bucardo_log_message(msg) VALUES (?)';
    $sth = $dbh->prepare($SQL);
    $sth->execute($nouns);
    $dbh->commit();
    $VERBOSE and print "Message added\n";
    exit 0;

} ## end of message


sub db_get_notices {

    ## Gather up and return a list of asynchronous notices received since the last check
    ## Arguments: one
    ## 1. Database handle
    ## Returns: arrayref of notices, each an arrayref of name and pid
    ## If using 9.0 or greater, the payload becomes the name

    my ($ldbh) = @_;

    my ($n, @notices);

    while ($n = $ldbh->func('pg_notifies')) {
        my ($name, $pid, $payload) = @$n;
        if ($ldbh->{pg_server_version} >= 9999990000) {
            next if $name ne 'bucardo';
            $name = $payload; ## presto!
        }
        push @notices => [$name, $pid];
    }

    return \@notices;

} ## end of db_get_notices


sub wait_for_notice {

    ## Keep hanging out until we get the notice we are waiting for
    ## Arguments: two
    ## 1. Database handle
    ## 2. String to listen for
    ## Returns: undef

    my ($ldbh, $string) = @_;

  WAITIN: {
        for my $notice (@{ db_get_notices($ldbh) }) {
            my ($name) = @$notice;
            last WAITIN if $name eq $string;
        }
        $dbh->commit();
        sleep($WAITSLEEP);
        redo;
    }

    return;

} ## end of wait_for_notice


sub install {

    print "This will install the bucardo database into an existing Postgres cluster.\n";
    print "Postgres must have been compiled with Perl support,\n";
    print "and you must connect as a superuser\n\n";
    print "We will create a new superuser named 'bucardo',\n";
    print "and make it the owner of a new database named 'bucardo'\n\n";

    my $ans;
    my $host = $bcargs->{dbhost} || $ENV{PGHOST} || '<none>';
    my $port = $bcargs->{dbport} || $ENV{PGPORT} || 5432;
    my $user = $ENV{DBUSER} || 'postgres';
    my $dbname = $ENV{DBNAME} || 'postgres';

    ## Make sure the bucardo.schema file is available, and extract some config items
    my ($fh, $schema_file) = find_bucardo_schema();
    my %confvar = (piddir => '');
    while (<$fh>) {
        for my $string (keys %confvar) {
            if (/^$string\|(.+?)\|/) {
                $confvar{$string} = $1;
            }
        }
    }
    close $fh or warn qq{Could not close "$schema_file": $!\n};
    for my $key (keys %confvar) {
        if (!$confvar{$key}) {
            warn "Could not find default configuration for $key!\n";
        }
    }

    my $piddir = $bcargs->{piddir} || $confvar{piddir};

  GOOEY:
    {

        print "Current connection settings:\n";

        print "1. Host:          $host\n";
        print "2. Port:          $port\n";
        print "3. User:          $user\n";
        print "4. Database:      $dbname\n";
        print "5. PID directory: $piddir\n";

        last GOOEY if $bcargs->{batch};

        print 'Enter a number to change it, P to proceed, or Q to quit: ';

        $ans = <>;
        print "\n";

        if ($ans =~ /^\s*(\d+)(.*)/) {
            my ($num,$text) = (int $1,$2);
            $text =~ s/^\s*(\S+)\s*$/$1/;
            my $new = length $text ? $text : '';
            if (1 == $num) {
                if (!length $new) {
                    print 'Change the host to: ';
                    $new = <>;
                    print "\n";
                    chomp $new;
                }
                $host = length $new ? $new : '<none>';
                print "Changed host to: $host\n";
            }
            elsif (2 == $num) {
                if (!length $new) {
                    print 'Change the port to: ';
                    $new = <>;
                    print "\n";
                    chomp $new;
                }
                if ($new !~ /^\d+$/) {
                    print "-->Sorry, but the port must be a number\n\n";
                    redo GOOEY;
                }
                $port = $new;
                print "Changed port to: $port\n";
            }
            elsif (3 == $num) {
                if (!length $new) {
                    print 'Change the user to: ';
                    $new = <>;
                    print "\n";
                    chomp $new;
                }
                if (! length $new) {
                    print "-->Sorry, you must specify a user\n\n";
                    redo GOOEY;
                }
                $user = $new;
                print "Changed user to: $user\n";
            }
            elsif (4 == $num) {
                if (!length $new) {
                    print 'Change the database name to: ';
                    $new = <>;
                    print "\n";
                    chomp $new;
                }
                if (! length $new) {
                    print "-->Sorry, you must specify a database name\n\n";
                    redo GOOEY;
                }
                $dbname = $new;
                print "Changed database name to: $dbname\n";
            }
            elsif (5 == $num) {
                if (!length $new) {
                    print 'Change the PID directory to: ';
                    $new = <>;
                    print "\n";
                    chomp $new;
                }
                if (! length $new) {
                    print "-->Sorry, you must specify a directory\n\n";
                    redo GOOEY;
                }
                if ($new !~ m{^/}) {
                    print "-->Sorry, the PID directory must be absolute (start with a slash)\n";
                    redo GOOEY;
                }
                if (! -d $new) {
                    print "-->Sorry, that is not a valid directory\n";
                    redo GOOEY;
                }
                $piddir = $new;
                print "Changed PID dir to: $piddir\n";
            }
        }
        elsif ($ans =~ /^\s*Q/i) {
            die "Goodbye!\n";
        }
        elsif ($ans =~ /^\s*P/i) {
            if (! -d $piddir) {
                print "-->Sorry, that is not a valid PID directory\n";
                redo GOOEY;
            }
            last GOOEY;
        }
        else {
            print "-->Please enter Q to quit, P to proceed, or enter a number to change a setting\n";
        }

        redo GOOEY;

    }

    my $PSQL = "psql -p $port -U $user -d $dbname";
    $host !~ /</ and $PSQL .= " --host=$host";

    my $COM = "$PSQL -c 'SELECT version()'";

    my $res = qx{$COM 2>&1};

    if ($res =~ /FATAL|ERROR/ or $res =~ /psql:/) {
        warn $res;
    }

    ## Check for some common errors
    if ($res =~ /role ".+" does not exist/) {
        die "Sorry, please try using a different user\n";
    }

    if ($res !~ /(\d+)\.(\d+)(\S+)/) {
        die "Sorry, unable to connect to the database\n";
    }
    my ($maj,$min,$rev) = ($1,$2,$3);
    $rev =~ s/^\.//;
    $rev =~ s/(\d+)\.\d+/$1/;

    print "Postgres version is: $maj.$min\n";

    if ($maj < 8 or (8 == $maj and $min < 1)) {
        die "Sorry, Bucardo requires Postgres version 8.1 or higher. This is only $maj.$min\n";
    }

    $COM = "$PSQL -AX -qt -f $schema_file 2>&1";
    #print "COM=$COM\n";

    print "Attempting to create and populate the bucardo database and schema\n";

    $res= qx{$COM};
    chomp $res;

    if ($res =~ /relation .* already exists/) {
        warn "\nINSTALLATION FAILED! Looks like you already have Bucardo installed there.\n";
        warn "Try running 'bucardo upgrade' instead\n\n";
        exit 1;
    }

    if ($res !~ m{Pl/PerlU was successfully installed}) {
        warn "\nINSTALLATION FAILED! ($res)\n\n";
        warn "Installation cannot proceed unless the Pl/PerlU language is available\n";
        warn "This is usually available as a separate package\n";
        warn "For example, you might try: yum install postgresql-plperl\n";
        warn "If compiling from source, add the --with-perl option to your ./configure command\n\n";
        exit 1;
    }

    print "Database creation is complete\n\n";

    ## Whether or not we really need to, change the bucardo_config items:

    print "Connecting to database 'bucardo' as user 'bucardo'\n";
    my $BDSN  = 'dbi:Pg:dbname=bucardo';
    $host and $host ne '<none>' and $BDSN .= ";host=$host";
    $port and $BDSN .= ";port=$port";
    my $default_bucardo_password = 'goat';
    $dbh = DBI->connect($BDSN, 'bucardo', $default_bucardo_password, {AutoCommit=>0,RaiseError=>1,PrintError=>0});
    $dbh->do('SET search_path = bucardo');

    $SQL = 'UPDATE bucardo.bucardo_config SET value = ? WHERE setting = ?';
    $sth = $dbh->prepare($SQL);
    $confvar{piddir} = $piddir;
    for my $key (sort keys %confvar) {
        $count = $sth->execute($confvar{$key}, $key);
        if ($count != 1) {
            warn "!! Failed to set $key to $confvar{$key}\n";
        }
        else {
            print qq{Updated configuration setting "$key"\n};
        }
    }
    $dbh->commit();

    print "Installation is now complete.\n\n";
    print "If you see any unexpected errors above, please report them to bucardo-general\@bucardo.org\n\n";

    print "You should probably check over the configuration variables next, by running:\n";
    print "$progname show all\n";
    print "Change any setting by using: $progname set foo=bar\n\n";

    exit 0;

} ## end of install


##
## Internal helper subs
##

sub debug {

    ## Print a debug line if needed
    ## Arguments: one
    ## 1. Srting to be printed
    ## Returns: nothing

    return if ! $DEBUG;

    my $string = shift;

    chomp $string;

    print " |DEBUG| $string\n";

    return;

} ## end of debug


sub process_simple_args {

    ## Process args to an inner function in the style of a=b
    ## Arguments: one
    ## 1. Custom hashref
    ## Returns: db column hashref, columns string, placeholders string,
    ##    values string, and 'extra' hashref

    my $arg = shift;
    my $validcols = $arg->{cols} or die 'Need a list of valid cols!';
    my $list = $arg->{list}      or die 'Need a list of arguments!';
    my $usage = $arg->{usage}    or die 'Need a usage!';

    my %item;
    my %dbcol;
    my %extra;
    my %alias;

    ## Transform array of x=y into a hashref
    my $xyargs = process_args(join ' ' => @$list);

    ## Parse the validcols string, and setup any non-null defaults
    for my $row (split /\n/ => $validcols) {
        next if $row !~ /\w/ or $row =~ /^#/;
        $row =~ /^\s*(\S+)\s+(\S+)\s+(\S+)\s+(.+)/ or die "Invalid valid cols ($row)";
        my ($args,$dbcol,$flag,$default) = ([split /\|/ => $1],$2,$3,$4);
        my $alias = @{$args}[-1];
        for my $name (@$args) {
            $item{$name} = [$dbcol,$flag,$default];
            $alias{$name} = $alias;
        }
        ## Process environment variable default
        if ($default =~ s/^ENV://) {
            for my $env (split /\|/ => $default) {
                if ($ENV{$env}) {

                    ## Skip if it starts with PG and this is not postgres
                    next if $env =~ /^PG/ and exists $xyargs->{type} and $xyargs->{type} ne 'postgres';

                    $dbcol{$dbcol} = $ENV{$env};
                    last;
                }
            }
        }
        elsif ($default ne 'null' and $default ne 'skip') {
            $dbcol{$dbcol} = $default;
        }
    }

    for my $arg (sort keys %$xyargs) {

        next if $arg eq 'extraargs';

        if (! exists $item{$arg}) {
            die "Unknown option '$arg'\n$usage\n";
        }

        (my $val = $xyargs->{$arg}) =~ s/^\s*(\S+)\s*$/$1/;

        if ($item{$arg}[2] eq 'skip') {
            $extra{$alias{$arg}} = $val;
            next;
        }

        my ($dbcol,$flag,$default) = @{$item{$arg}};
        if ($flag eq '0') {
            ## noop
        }
        elsif ($flag eq 'TF') {
            $val =~ s/^\s*t(?:rue)*\s*$/1/i;
            $val =~ s/^\s*f(?:alse)*\s*$/0/i;
            if ($val !~ /^[01]$/) {
                die "Invalid value for '$arg': must be true of false\n";
            }
        }
        elsif ($flag eq 'numeric') {
            if ($val !~ /^\d+$/) {
                die "Invalid value for '$arg': must be numeric\n";
            }
        }
        elsif ($flag =~ /^=(.+)/) {
            my $ok = 0;
            for my $okval (split /\|/ => $1) {
                if ($okval =~ /~/) { ## aliases - force to the first one
                    my @alias = split /~/ => $okval;
                    for my $al (@alias) {
                        if ($val eq $al) {
                            $ok = 1;
                            last;
                        }
                    }
                    if ($ok) {
                        $val = $alias[0];
                        last;
                    }
                }
                elsif (lc $val eq lc $okval) {
                    $ok = 1;
                    last;
                }
            }
            if (!$ok) {
                (my $arglist = $flag) =~ s/\|/ or /g;
                $arglist =~ s/^=//;
                $arglist =~ s/~\w+//g;
                die "Invalid value for '$arg': must be one of $arglist\n";
            }
        }
        elsif ($flag eq 'interval') {
            ## Nothing for now
        }
        else {
            die "Unknown flag '$flag' for $arg";
        }

        ## Value has survived our minimal checking. Store it and clobber any default
        $dbcol{$dbcol} = $val;

    }

    ## Apply any magic
    if (exists $arg->{morph}) {
        for my $mline (@{$arg->{morph}}) {
            if (exists $mline->{field}) {
                next unless exists $dbcol{$mline->{field}};
                next if $dbcol{$mline->{field}} ne $mline->{value};
                for my $change (split /\s+/ => $mline->{new_defaults}) {
                    my ($f,$v) = split /\|/ => $change;
                    next if exists $dbcol{$f};
                    $dbcol{$f} = $v;
                }
            }
            else {
                die "Do not know how to handle that morph!\n";
            }
        }
    }


    ## Build the lists of columns and placeholders for the SQL statement
    my ($cols,$phs,$vals) = ('','',{});
    for my $col (sort keys %dbcol) {
        $cols .= "$col,";
        $phs .= '?,';
        $vals->{$col} = $dbcol{$col};
    }
    $cols =~ s/,$//;
    $phs =~ s/,$//;

    return \%dbcol, $cols, $phs, $vals, \%extra;

} ## end of process_simple_args


sub check_recurse {

    ## Call a sub recursively depending on first argument

    my ($thing, $name, @actions) = @_;

    my $caller = (caller(1))[3];

    ## If the name is 'all', recursively call on all objects of this type
    if ($name =~ /all/i) {
        for my $item (sort keys %$thing) {
            &$caller($item, @actions);
        }
        return 0;
    }

    ## If we have a wildcard, recursively call all matching databases
    if ($name =~ s/[*%]/\.*/g) {
        my @list = grep { $_ =~ /^$name$/ } keys %$thing;
        if (! @list) {
            die qq{No matching items found\n};
        }
        for my $item (sort @list) {
            &$caller($item, @actions);
        }
        return 0;
    }

    return 1;

} ## end of check_recurse


sub extract_name_and_role {

    ## Given a group or db name with optional role information, return both
    ## Also returns optional list of other items, e.g. ABC:slave:pri=2:gangs=2
    ## Arguments: one
    ## 1. Group or database name: 'foo' or 'foo:master'
    ## Returns: name, role name, and hashref of 'extra' info

    my $name = shift or die;

    ## Role always defaults to 'target'
    my $role = 'target';

    ## Check for a role attached to the group name
    if ($name =~ s/:([^:]+)//) {
        $role = lc $1;
    }

    ## Look for any additional items
    my %extra;
    while ($name =~ s/:([^:]+)//) {
        my $extra = $1;
        if ($extra !~ /(\w+)=([\w\d]+)/) {
            die qq{Invalid value "$extra"\n};
        }
        my ($name,$val) = ($1,$2);
        if ($name =~ /make?delta/i) {
            $extra{'makedelta'} = make_boolean($val);
        }
        elsif ($name =~ /gang/i) {
            $extra{'gang'} = $val;
        }
        elsif ($name =~ /pri/i) {
            $extra{'priority'} = $val;
        }
        else {
            die qq{Unknown value "$name": must be priority, gang, or makedelta\n};
        }
    }

    ## Valid group name?
    if ($name !~ /^[\w\d]+$/) {
        die "Invalid name: $name\n";
    }

    ## Valid role name?
    if ($role !~ /^(?:master|target|slave|rep|replica|source)$/) {
        die "Invalid database role: $role\n";
    }

    ## Standardize the names
    $role = 'source' if $role =~ /master/;
    $role = 'target' if $role =~ /slave|rep|tar/;

    return $name, $role, \%extra;

} ## end of extract_name_and_role


sub load_bucardo_info {

    ## Load of all information from the database into global hashes
    ## Arguments: one
    ## 1. Boolean: if true, force run even if we've run once already
    ## Returns: undef

    my $force = shift || 0;

    return if exists $global{db} and ! $force;

    ## Grab all database information
    $SQL = 'SELECT *, EXTRACT(epoch FROM cdate) AS epoch FROM bucardo.db';
    $sth = $dbh->prepare($SQL);
    $sth->execute();
    my $db = $sth->fetchall_hashref('name');

    ## Grab all database information
    $SQL = 'SELECT * FROM bucardo.dbgroup';
    $sth = $dbh->prepare($SQL);
    $sth->execute();
    my $dbgroup = $sth->fetchall_hashref('name');

    ## Figure out if each dbgroup is using multiple gangs
    my %gang;

    ## Map databases to their groups
    $SQL = 'SELECT * FROM bucardo.dbmap';
    $sth = $dbh->prepare($SQL);
    $sth->execute();
    for my $row (@{$sth->fetchall_arrayref({})}) {
        $db->{$row->{db}}{group}{$row->{dbgroup}} = $row;

        ## Tally up the roles each database fills
        $db->{$row->{db}}{roles}{$row->{role}}++;

        ## Mark if this db is ever used as a source, for help in adding table
        $db->{$row->{db}}{issource}++ if $row->{role} eq 'source';

        $dbgroup->{$row->{dbgroup}}{db}{$row->{db}} = $row;
        ## Figure out how many gangs each group has
        $gang{$row->{dbgroup}}{$row->{gang}}++;
    }

    for my $group (keys %$dbgroup) {
        $dbgroup->{$group}{gangs} = keys %{ $gang{$group} };
    }

    ## Grab all goat information
    $SQL = 'SELECT * FROM bucardo.goat';
    $sth = $dbh->prepare($SQL);
    $sth->execute();
    my $goat = $sth->fetchall_hashref('id');
    ## Since relations cannot start with a number, we can also safely add the name to the hash
    for my $key (%$goat) {
        next if $key !~ /^\d/;
        my $tname = $goat->{$key}{tablename};
        my $name = "$goat->{$key}{schemaname}.$tname";
        $goat->{$name} = $goat->{$key};
        ## Also want a table-only version:
        push @{$goat->{$tname}} => $goat->{$key};
    }

    ## Grab all herd information
    $SQL = 'SELECT * FROM bucardo.herd';
    $sth = $dbh->prepare($SQL);
    $sth->execute();
    my $herd = $sth->fetchall_hashref('name');

    ## Grab all herdmap information, stick into previous hashes
    $SQL = 'SELECT * FROM bucardo.herdmap ORDER BY priority DESC, goat ASC';
    $sth = $dbh->prepare($SQL);
    $sth->execute();
    for my $row (@{$sth->fetchall_arrayref({})}) {
        my ($g,$h,$p) = @$row{qw/goat herd priority/};
        $goat->{$g}{herd}{$h} = $p;
        $herd->{$h}{goat}{"$goat->{$g}{schemaname}.$goat->{$g}{tablename}"} = {
            id       => $g,
            priority => $p,
            reltype  => $goat->{$g}{reltype},
            schema   => $goat->{$g}{schemaname},
            table    => $goat->{$g}{tablename},
        };
        my ($s,$t) = @{$goat->{$g}}{qw/schemaname tablename/};
        $herd->{$h}{hasgoat}{$s}{$t} = $p;
        ## Assign each herd to a datbase via its included goats
        $herd->{$h}{db} = $goat->{$g}{db};
    }

    ## Grab all sync information
    $SQL = 'SELECT * FROM bucardo.sync';
    $sth = $dbh->prepare($SQL);
    $sth->execute();
    my $sync;
    for my $row (@{$sth->fetchall_arrayref({})}) {
        my ($name,$p,$sherd,$dbs) = @$row{qw/name priority herd dbs/};
        $sync->{$name} = $row;
        ## Add in herd information
        $sync->{$name}{herd} = $herd->{$sherd};
        ## Add this sync back to the herd
        $herd->{$sherd}{sync}{$name}++;
        ## Grab the databases used by this sync
        $sync->{$name}{dblist} = $dbgroup->{$dbs}{db};
        ## Map each database back to this sync, along with its type (source/target)
        for my $dbname (keys %{ $sync->{$name}{dblist} }) {
            $db->{$dbname}{sync}{$name} = $sync->{$name}{dblist}{$dbname};
        }
    }

    ## Grab all customcode information
    $SQL = 'SELECT * FROM bucardo.customcode';
    $sth = $dbh->prepare($SQL);
    $sth->execute();
    my $cc = $sth->fetchall_hashref('name');
    $SQL = 'SELECT * FROM bucardo.customcode_map';
    $sth = $dbh->prepare($SQL);
    $sth->execute();
    my %codename;
    for my $row (values %$cc) {
        $codename{$row->{id}} = $row->{name};
    }
    for my $row (@{$sth->fetchall_arrayref({})}) {
        my $codename = $codename{$row->{code}};
        push @{$cc->{$codename}{map}} => $row;
    }

    $global{cc} = $cc;
    $global{dbgroup} = $DBGROUP = $dbgroup;
    $global{db}      = $DB   = $db;
    $global{goat}    = $GOAT = $goat;
    $global{herd}    = $HERD = $herd;
    $global{sync}    = $SYNC = $sync;

    return;

} ## end of load_bucardo_info


sub transform_name {

    ## Change a given word to a more standard form
    ## Generally used for database column names, which follow some simple rules
    ## Arguments: one
    ## 1. Name to transform
    ## Returns: transformed name

    my $name = shift;

    ## Complain right away if these are not standard characters
    if ($name !~ /^([\w ]+)$/) {
        die "Invalid name: $name\n";
    }

    ## Change to lowercase
    $name = lc $name;

    ## Change dashes and spaces to underscores
    $name =~ s{[- ]}{_}go;

    ## Compress all underscores
    $name =~ s{__+}{_}go;

    ## Fix common spelling errors
    $name =~ s{perpare}{prepare}go;

    ## Look up standard abbreviations
    if (exists $alias{$name}) {
        $name = $alias{$name};
    }

    return $name;

} ## end of transform_name


sub transform_value {

    ## Change a value to a more standard form
    ## Used for database column SET actions
    ## Arguments: one
    ## 1. Value
    ## Returns: transformed value

    my $value = shift;

    ## Remove all whitespace on borders
    $value =~ s/^\s*(\S+)\s*$/$1/;

    ## Change booleans to 0/1
    $value =~ s/^(?:t|true)$/1/io;
    $value =~ s/^(?:f|false)$/0/io;

    return $value;

} ## end of transform_value


sub make_boolean {

    ## Transform some string into a strict boolean value
    ## Arguments: one
    ## 1. String to be analyzed
    ## Returns: 'true' or 'false' (unquoted)

    my $value = shift;

    $value = lc $value;

    return 'true' if $value =~ /^(?:t|true|1|yes)$/o;

    return 'false' if $value =~ /^f|false|0|no$/o;

    die "Invalid value: must be 'true' of 'false'\n";

} ## end of make_boolean


sub find_best_db_for_searching {

    ## Returns the db from $DB most likely to contain tables to add
    ## Basically, we use source ones first, then the date added
    ## Arguments: none
    ## Returns: database name or undef if no databases defined yet

    for my $db (
        map { $_->[0] }
        sort {
            ## Source databases are always first
            $a->[1] <=> $b->[1]
            ## First created are first
            or $a->[2] <=> $b->[2]
            ## All else fails, sort by name (should not happen)
            or $b->[0] cmp $a->[0] }
        map { [
               $_,
               exists $DB->{$_}{issource} ? 0 : 1,
               $DB->{$_}{epoch},
               lc $_,
              ]
            }
        keys %{ $DB } ) {
        return $db;
    }

    ## Probably an error, but let the caller handle it:
    return undef;

} ## end of find_best_db_for_searching


##
## Subs to perform common SQL actions
##

sub confirm_commit {

    ## Perform a database commit unless the user does not want it
    ## Arguments: none
    ## Returns: true for commit, false for rollback

    ## The dryrun option overrides everything else: we never commit
    if ($bcargs->{dryrun}) {
        $VERBOSE and print "In dryrun mode, so no going to commit database changes\n";
        return 0;
    }

    if ($bcargs->{confirm}) {
        print "Commit the changes? Y/N ";
        if (<STDIN> !~ /Y/i) {
            $dbh->rollback();
            print "Changes have been rolled back\n";
            return 0;
        }
        else {
            $dbh->commit();
            print "Changes have been committed\n";
        }
    }
    else {
        $dbh->commit();
    }

    return 1;

} ## end of confirm_commit


sub create_dbgroup {

    ## Creates a new entry in the bucardo.dbgroup table
    ## Caller should have alredy checked for existence
    ## Does not commit
    ## Arguments: two
    ## 1. Name of the new group
    ## 2. Boolean: if true, prevents the reload
    ## Returns: undef

    my ($name,$noreload) = @_;

    $SQL = 'INSERT INTO bucardo.dbgroup(name) VALUES (?)';
    $sth = $dbh->prepare($SQL);
    eval {
        $sth->execute($name);
    };
    if ($@) {
        if ($@ =~ /dbgroup_name_sane/) {
            print qq{Invalid characters in database group name "$name"\n};
        }
        else {
            print qq{Failed to create database group "$name"\n$@\n};
        }
        exit 1;
    }

    ## Reload our hashes
    $noreload or load_bucardo_info(1);

    return;

} ## end of create_dbgroup


sub add_db_to_group {

    ## Add a database to a group
    ## Will create the group as needed
    ## Does not commit
    ## Arguments: two
    ## 1. Database name
    ## 2. Group name (may have :role specifier)
    ## Returns: group name and role name

    my ($db,$fullgroup) = @_;

    ## Figure out the role. Defaults to target
    my ($group,$role) = extract_name_and_role($fullgroup);

    if (! exists $DBGROUP->{$group}) {
        ## Extra argument prevents load_bucardo_info from being called by the sub
        create_dbgroup($group, 1);
    }

    $SQL = 'INSERT INTO bucardo.dbmap(db,dbgroup,role) VALUES (?,?,?)';
    $sth = $dbh->prepare($SQL);
    eval {
        $sth->execute($db,$group,$role);
    };
    if ($@) {
        my $msg = qq{Cannot add database "$db" to group "$group"};
        if ($@ =~ /"db_dsn_unique"/) {
            die qq{$msg: already have that entry\n};
        }
        die qq{$msg: $@\n};
    }

    ## Reload our hashes
    load_bucardo_info(1);

    return $group, $role;

} ## end of add_db_to_group


sub remove_db_from_group {

    ## Removes a database from a group: deletes from bucardo.dbmap
    ## Does not commit
    ## Arguments: two
    ## 1. Database name
    ## 2. Group name
    ## 3. Boolean: if true, prevents the reload
    ## Returns: undef

    my ($db,$group,$noreload) = @_;

    $SQL = 'DELETE FROM bucardo.dbmap WHERE db=? AND dbgroup=?';
    $sth = $dbh->prepare_cached($SQL);
    $sth->execute($db, $group);

    ## Reload our hashes
    $noreload or load_bucardo_info(1);

    return;

} ## end of remove_db_from_group


sub change_db_role {

    ## Changes the role of a database: updates bucardo.dbmap
    ## Does not commit
    ## Arguments: four
    ## 1. New role
    ## 2. Name of the dbgroup
    ## 3. Name of the database
    ## 4. Boolean: if true, prevents the reload
    ## Returns: undef

    my ($role,$group,$db,$noreload) = @_;

    $SQL = 'UPDATE bucardo.dbmap SET role=? WHERE dbgroup=? AND db=?';
    $sth = $dbh->prepare_cached($SQL);
    $sth->execute($role,$group,$db);

    ## Reload our hashes
    $noreload or load_bucardo_info(1);

    return;

} ## end of change_db_role


sub update_dbmap {

    ## Update the values in the bucardo.dbmap table
    ## Arguments: three
    ## 1. Name of the database
    ## 2. Name of the database group
    ## 3. Hashref of things to change
    ## Returns: undef

    my ($db,$group,$changes) = @_;

    ## This should not need quoting as they are all [\w\d]
    my $list = join ',' => map { "$_=$changes->{$_}" } sort keys %$changes;

    $SQL = "UPDATE bucardo.dbmap SET $list WHERE db=? AND dbgroup=?";
    $sth = $dbh->prepare($SQL);
    $sth->execute($db, $group);

    return;

} ## end of update_dbmap


sub create_herd {

    ## Creates a new entry in the bucardo.herd table
    ## Caller should have alredy checked for existence
    ## Does not commit
    ## Arguments: two
    ## 1. Name of the new herd
    ## 2. Boolean: if true, prevents the reload
    ## Returns: undef

    my ($name,$noreload) = @_;

    $SQL = 'INSERT INTO bucardo.herd(name) VALUES (?)';
    $sth = $dbh->prepare($SQL);
    eval {
        $sth->execute($name);
    };
    if ($@) {
        print qq{Failed to create database group "$name"\n$@\n};
        exit 1;
    }

    ## Reload our hashes
    $noreload or load_bucardo_info(1);

    return;

} ## end of create_herd



__END__

=head1 NAME

bucardo - utility script for controlling the Bucardo program

=head1 VERSION

This document describes version 5.0.0 of bucardo

=head1 SYNOPSIS

  ./bucardo install

  ./bucardo list dbs

  ./bucardo add sync testsync source=herd1 type=pushdelta targetdb=B

  ./bucardo add sync testsync source=herd1 type=pushdelta targetdb=B tables=tab1,tab2,tab3

  ./bucardo add database newdb name=internal_name port=5432 host=myserver

  ./bucardo add all tables db=foo [herd=x] [pkonly]

  ./bucardo add all sequences db=foo [herd=x]

  ./bucardo add herd newherd table1 table2 table3 ...

  ./bucardo add dbgroup name db1 db2 db3 ...

  ./bucardo start "Starting up - Greg"

  ./bucardo stop "Bringing down for debugging - Raul E."

  ./bucardo ping

  ./bucardo status

  ./bucardo status sync1 sync2

  ./bucardo kick sync1 sync2

  ./bucardo kick sync1 0

  ./bucardo reload_config

  ./bucardo upgrade

  ./bucardo reload sync

  ./bucardo validate sync

  ./bucardo message "Your message here"

  ./bucardo config show

  ./bucardo config set foo=bar baz=123


=head1 DESCRIPTION

The bucardo script is the main interaction to a running Bucardo instance. It can 
be used to start and stop Bucardo, add new items, kick syncs, and even install and 
upgrade Bucardo itself. For more complete documentation, please view the wiki at:

http://bucardo.org/

=head1 COMMANDS

=over 4

=item B<install>

Usage: ./bucardo install

Attempts to install the Bucardo schema from the file 'bucardo.schema' into an existing 
Postgres cluster. The user 'bucardo' and database 'bucardo' will be created first as needed.
This is an interactive installer, but you can supply the following values from the command 
line:

=over 2

=item --dbuser (defaults to postgres)

=item --dbname (defaults to postgres)

=item --dbport (defaults to 5432)

=item --piddir (defaults to /var/run/bucardo/)

=back

=item B<upgrade>

Usage: ./bucardo upgrade

Upgrades an existing Bucardo installation to the current version of the bucardo script. 
Requires that the bucardo script and the bucardo.schema file be the same version. All 
changes should be backwards compatible, but you may need to re-validate existing scripts 
to make sure changes get propagated to all databases.

=item B<start>

Usage: ./bucardo start "Reason --name"

Restarts Bucardo cleanly by first issuing the equivalent of a stop to ask any existing Bucardo 
processes to exit, and then starting a new Bucardo MCP process. A short reason and name should 
be provided - these are logged in the reason_file file and sent in the email sent when Bucardo 
has been started up.

Before attempting to kill any old processes, a ping command with a timeout of 5 seconds is issued. 
If this returns successfully (indicating an active MCP process already running), the script will 
exit with a return value of 2.

=item B<stop>

Usage: ./bucardo stop "Reason --name"

Forces Bucardo to quit by creating a stop file which all MCP, CTL, and KID processes should 
detect and cause them to exit. Note that active syncs will not exit right away, as they 
will not look for the stop file until they have finished their current run. Typically, 
you should scan the list of processes after running this program to make sure that all Bucardo 
processes have stopped. One should also provide a reason for issuing the stop - usually 
this is a short explanation and your name. This is logged in the reason_file file and 
is also used by Bucardo when it exits and sends out mail about its death.

=item B<list>

Usage: ./bucardo list <type> <regex>

Lists summary information about databases, tables, sequences, syncs, or herds. Adding anything 
after the type will look up all matching entries.

=item B<add>

Usage:  add <item_type> <item_name>

Usage:  add database <dbname> name=internal_name port=xxx host=xxx user=xxx pass=xxx service=xxx conn=xxx sourcelimit=xxx targetlimit=xxx ssp=1/0

Usage:  add table [schema].table db=internal_db_name ping=bool standard_conflict=xxx herd=xxx

Usage:  add all tables [herd=xxx] [pkonly]

Usage:  add sequence [schema].table herd=xxx

Usage:  add all sequences herd=xxx

Usage:  add sync syncname options

Usage:  add herd name

Usage:  add dbgroup name db1 db2 db3 ...

Tells Bucardo about new objects it should know about. These commands can
replace direct manipulation of the tables in the bucardo schema for the
supported object types (you'll still need to add things like the mappings between objects on your own).

=item B<remove>

Usage:  remove <item_type> <item_name>

Removes one or more items from the Bucardo database. Valid item types are database, 
dbgroup, herd, sync, table, and sequence.

=item B<kick>

Usage: ./bucardo kick <syncname(s)> [timeout]

Tells one or more named syncs to fire as soon as possible. Note that this simply sends a request that 
the sync fire: it may not start right away if the same sync is already running, or if the source or 
target database has exceeded the number of allowed Bucardo connections. If the final argument is a 
number, it is treated as a timeout. If this number is zero, the bucardo command will not return 
until the sync has finished. For any other number, the sync will wait at most that number of seconds. 
If any sync has not finished before the timeout, a false value is returned. In all other cases, a 
true value is returned.

If a timeout is given, the total completion time in seconds is also displayed. If the sync is going to 
multiple targets, the time that each target takes from the start of the kick is also shown as each 
target finishes.

=item B<reload_config>

Forces Bucardo to reload the bucardo_config file, and then restart all processes to ensure that the new 
information is loaded.

=item B<show>

Usage: ./bucardo show <all|setting1> [setting2..]

Shows the current values in the bucardo_config table. Use the keyword 'all' to see all the settings, or 
specify one or more search terms.

=item B<set>

Usage: ./bucardo set setting1=value [setting2=value]

Sets one or more items inside the bucardo_config table. Setting names are case-insensitive.

=item B<ping>

Sends a ping notice to the MCP process to see if it will respond. By default, it will wait 15 seconds. A 
numeric argument will change this timeout. Using a 0 as the timeout indicates waiting forever. If a response 
was returned, the program will exit with a value of 0. If it times out, the value will be 1.

=item B<status>

Usage: ./bucardo status [syncname(s)] [--sort=#] [--daysback=#] [--showdays]

Shows the current status of all known syncs in a tabular format. If given one or more syncnames, 
shows detailed information for each one.

When showing all syncs, the columns are:

=over 8

=item 1. B<Name>

The name of the sync

=item 2. B<Type>

The type of the sync. C<F> = fullcopy, C<S> = swap, C<P> = pushdelta. In addition, if a sync is overdue, a C<O!> will 
appear, and if it is expired, a C<E!> will appear.

=item 3. B<State>

The current status of this sync. If no sync is running, C<idle> will appear. If a sync has been requested, but has not 
started yet, C<WAIT> will appear, along with how long since the sync was requested. If a sync is 
currently running, C<RUN> will appear, followed by the amount of time the sync has been running, followed by which 
target the sync is running against. Note that syncs running to more than one database at a time will only show 
the one most recently started.

=item 4. B<PID>

The PID of the current sync's controller (CTL). Note that if this is not a persistent sync and the state is C<idle>, 
this is merely a historical record and does not represent an active process.

=item 5. B<Last_good>

How long since this sync last ran successfully. Remember that this is affected by the --daysback parameter.

=item 6. B<Time>

The amount of time the last successful sync took to run.

=item 7. B<I/U/D>

The number of inserts. updates, and deletes performed by the last successful sync.

=item 8. B<Last_bad>

How long since this sync failed to run successfully. Strongly affected by the --daysback parameter.

=item 9. B<Time>

The amount of time the last failed sync took before it was aborted.

=back


=item B<activate> syncname [syncname2 syncname3 ...] [timeout]

Activates one or more named syncs. If given a timeout argument, it will wait until it has received 
confirmation from Bucardo that each sync has been successfully activated.

=item B<deactivate> syncname [syncname2 syncname3 ...] [timeout]

Deactivates one or more named syncs. If given a timeout argument, it will wait until it has received 
confirmation from Bucardo that the sync has been successfully deactivated.

=item B<message>

Adds a message to the running Bucardo logs. This message will appear prefixed with "MESSAGE: ". If 
Bucardo is not running, the message will go to the logs the next time Bucardo is running and someone 
adds another message.

=back

=head1 OPTIONS

It is usually easier to set most of these options at the top of the script, or make an alias for them, 
as they will not change very often if at all.

=over 4

=item B<--dbport=number>

=item B<--dbhost=string>

=item B<--dbname=string>

=item B<--dbuser=string>

=item B<--dbpass=string>

The port, host, and name of the Bucardo database, the user to connect as, and the password to use.

=item B<--verbose>

Makes bucardo run verbosely. Default is off.

=item B<--quiet>

Tells bucardo to be as quiet as possible. Default is off.

=item B<--help>

Shows a brief summary of usage for bucardo.

=back

=head2 Kick arguments

The following arguments are only used with the 'kick' command:

=over 4

=item B<--retry=#>

The number of times to retry a sync if it fails. Defaults to 0.

=item B<--retrysleep>

How long to sleep, in seconds, between each retry attempt.

=item B<--notimer>

By default, kicks with a timeout argument give a running real-time summary of time elapsed by 
using the backspace character. This may not be wanted if running a kick, for example, 
via a cronjob, so turning --notimer on will simply print the entire message without backspaces.

=back

=head2 Status arguments

The following arguments are only used with the 'status' command:

=over 4

=item B<--daysback=#>

Sets how many days backwards to search the old 'q' logs for information. Defaults to 3 days.

=item B<--showdays>

Specifies whether or not do list the time interval with days, or simply show the hours. For example, 
"3d 12h 6m 3s" vs. "48h 6m 3s"

=item B<--compress>

Specifies whether or not to compress the time interval by removing spaces. Mostly used to limit 
the width of the 'status' display.

=item B<--sort=#>

Requests sorting of the 'status' output by one of the nine columns. Use a negative number to reverse 
the sort order.

=back

=head2 Startup arguments

The following arguments are only applicable when using the "start" command:

=over 4

=item B<--sendmail>

Tells Bucardo whether or not to send mail on interesting events: startup, shutdown, and errors. Default is on.
Only applicable when using ./bucardo start.

=item B<--extraname=string>

A short string that will be appended to the version string as output by the Bucardo process names. Mostly 
useful for debugging.

=item B<--debugfilesep>

Forces creation of separate log files for each Bucardo process of the form "log.bucardo.X.Y", 
where X is the type of process (MCP, CTL, or KID), and Y is the process ID.

=item B<--debugsyslog>

Sends all log messages to the syslog daemon. On by default. The facility used is controlled by 
the row "syslog_facility" in the bucardo_config table, and defaults to "LOG_LOCAL1".

=item B<--debugfile>

If set, writes detailed debugging information to one or more files.

=item B<--debugdir=directory name>

Directory where the debug files should go.

=item B<--debugname=string>

Appends the given string to the end of the default debug file name, "log.bucardo". A dot is added 
before the name as well, so a debugname of "rootdb" would produce a log file named "log.bucardo.rootdb".

=item B<--cleandebugs>

Forces removal of all old debug files before running.

=back

=head1 FILES

In addition to command-line configurations, you can put any options inside of a file. The file F<.bucardorc> in 
the current directory will be used if found. If not found, then the file F<~/.bucardorc> will be used. Finally, 
the file /etc/bucardorc will be used if available. The format of the file is option = value, one per line. Any 
line starting with a '#' will be skipped. Any values loaded from a bucardorc file will be overwritten by 
command-line options. All bucardorc files can be ignored by supplying a C<--no-bucardorc> argument. A specific 
file can be forced with the C<--bucardorc=file> option; if this option is set, bucardo will refuse to run 
unless that file can be read.

=head1 ENVIRONMENT VARIABLES

The bucardo script uses I<$ENV{HOME}> to look for a F<.bucardorc> file.

=head1 BUGS

The 'status' command does not yet return current information, and the start time in particular should be 
taken with a grain of salt.

Bug reports and feature requests are always welcome, please visit http://bucardo.org or email bucardo-general@bucardo.org.

=head1 SEE ALSO

Bucardo

=head1 COPYRIGHT

Copyright 2006-2011 Greg Sabino Mullane <greg@endpoint.com>

This program is free to use, subject to the limitations in the LICENSE file.

=cut

